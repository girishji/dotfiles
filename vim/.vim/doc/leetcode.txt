*leetcode.txt*

------------------------------------------------------------------------------
When you are looking for some 'minimum' in what looks like graph traversal~
use BFS or Dijkshtra. Do not use DFS/recursion even if it looks easy to
implement, and even with remoization/DP.

------------------------------------------------------------------------------
Perf speedup for string contactinations~
use an array and then join().
Use itertools.zip_longest() instead of zip() when two sequences differ by
length
p1768

There is functools and itertools~
To multiply all elements of a list
>
	>>> from functools import reduce
	>>> reduce(lambda x, y: x*y, [1, 2, 3, 4, 5, 6])
	720

Similary, `map()` has its place.
>
	>>> map(int, myiterable)
	calles int(x) on each element x of myiterable

------------------------------------------------------------------------------
Split string into list of characters~
>
	% list('foobar')

Reminder and quotent in one function~
>
	% divmod(10, 3)

Split lines~
Better to use `()` instead of `\`
>
	x = (foo and bar and
		barfoo and foobar)

------------------------------------------------------------------------------
regex~

There is no `=~` operator in Python. Use `re.search(r'pat', str)` instead. Get
the matching string by calling `.group()` to above. Also, use `.span()`,
`.start()`, `.end()`, since `search()` returns a 'match' object.
To find all matches, not just the first, use `re.finditer()`. `re.findall()`
does not let you use group(), span(), etc.

Use raw strings and you don't need to escape (, ), [, ], etc.

match(), search(), findall(), finditer().

Inside a for loop use compiled pattern:
>
     >>> p = re.compile(r'\d+')
     >>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
     ['12', '11', '10']

Module level functions:
>
     >>> print(re.match(r'From\s+', 'Fromage amk'))
     None
     >>> re.match(r'From\s+', 'From amk Thu May 14 19:12:10 1998')
     <re.Match object; span=(0, 5), match='From '>

Methods of match object: `span()`, `start()`, `end()`, `group()`.

Should you use these module-level functions, or should you get the
  pattern and call its methods yourself?  If you’re accessing a regex
  within a loop, pre-compiling it will save a few function calls.
  Outside of loops, there’s not much difference thanks to the internal
  cache.

|howto-regex.pyx|
:Help howto-regex

To concatenate raw strings:

Use `str.format()`:
>
	MyID = 'X12345'
	MasterFile_Name = r'C:\Users\ABC\{}\DEF\File - Test.xlsx'.format(MyID)  

Type `{` to escape `{`. To get r'(?=([?#]{5}(?!#)))' do (counts[0] == 5):
>
    	pat = r'(?=([?#]{{{}}}(?!#)))'.format(counts[0])

How to negate specific word in regex?~
I know that I can negate group of chars as in `[^bar]` but I need a regular
expression where negation applies to the specific word - so in my example how
do I negate an actual `bar,` and not "any chars in bar"?

A great way to do this is to use negative lookahead
(https://www.regular-expressions.info/lookaround.html):
>
	^(?!.*bar).*$

The negative lookahead construct is the pair of parentheses, with the opening
parenthesis followed by a question mark and an exclamation point - `(?!`. Inside the
lookahead [is any regex pattern].

"Lookahead and lookbehind, collectively called “lookaround”, are zero-length
assertions just like the start and end of line, and start and end of word
anchors explained earlier in this tutorial. The difference is that lookaround
actually matches characters, but then gives up the match, returning only the
result: match or no match. That is why they are called “assertions”. They do
not consume characters in the string, but only assert whether a match is
possible or not..."

Positive and Negative Lookahead~

To match a `q` not followed by a `u,` negative lookahead provides the solution: `q(?!u)`.

Positive lookahead works just the same. `q(?=u)` matches a `q` that is followed by
a `u,` without making the u part of the match.

Positive and Negative Lookbehind~

Lookbehind has the same effect, but works backwards. It tells the regex engine
to temporarily step backwards in the string, to check if the text inside the
lookbehind can be matched there. `(?<!a)b` matches a “b” that is not preceded by
an “a”, using negative lookbehind. It doesn’t match `cab,` but matches the `b`
(and only the `b)` in `bed` or `debt.` `(?<=a)b` (positive lookbehind) matches the `b`
(and only the `b)` in `cab,` but does not match `bed` or `debt.`

Overlapping patterns in regex~

How do you match 'one' and 'eight' both in 'oneight'?

`findall` doesn't yield overlapping matches by default. But you can use lookahead assertion:

(?=...) lookahead assertion:

(?=...) matches if ... matches next, but doesn’t consume any of the string.
This is called a lookahead assertion. For example, Isaac (?=Asimov) will match
'Isaac ' only if it’s followed by 'Asimov'.

It is important to note that lookahead does not consume string, so the next
match can start right at the point where lookahead matched.
>
	>>> match1 = re.findall(r'el', 'hello')
	>>> print match1
	['el']
	# here the cursor advanced to 'i' and it cannot find 'eight'
	>>> match1 = re.findall(r'(one|eight)', 'oneight'?
	['one']
	
	>>> re.findall(r'(?=(\w\w))', 'hello')
	['he', 'el', 'll', 'lo']
	>>> re.findall(r'(?=(one|eight))', 'oneight')
	['one', 'eight']

You can match repeated patterns by capturing (use \1, \2, etc.)~
Following matches `s*s*` in `ats*s*asd`. For meaning of `\w` see `:Help re.pyx`.
>
        m = re.search(r'(\w)\*\1\*', p)

------------------------------------------------------------------------------
To convert string to a list of characters~
> list('asdf')
Out[5]: ['a', 's', 'd', 'f']

problem: reverse all vowels in a string. hello->holle~
better solution:
- create a reverse iterator object (from a generator expression)
- Use join() to create string out of iterator (from another generator
  expression)
class Solution:
    def reverseVowels(self, s: str) -> str:
        it = (ch for ch in s[::-1] if ch.lower() in 'aeiou')
        return ''.join(next(it) if ch.lower() in 'aeiou' else ch for ch in s)
p345
------------------------------------------------------------------------------
python:
    In insert mode <c-d> unindents; in normal mode use << and >> (hold shift
key)

" vs ` ~
They are interchangeable. You can use one inside another.

------------------------------------------------------------------------------
File idiom~
>
	with open('filename') as f: # default mode is 'r'
	    for line in f:
	        pass
	    f.seek(0) # resets the file cursor to beginning

to read entire file into memory where each line is a list item use `f.readlines()`.
`f.read()` reads entire file into one string
	
------------------------------------------------------------------------------
p238: When they say you cannot do something (like division), think of caching
lots of intermediate values. In this case keep a suffix product list.

Given an integer array nums, return an array answer such that answer[i] is
equal to the product of all the elements of nums except nums[i].

You must write an algorithm that runs in O(n) time and without using the
division operation.

Instead of appending to list, initialize length:
        result = [1] * nlen

------------------------------------------------------------------------------
To create integer infinity (large value) use float('inf'):~
float('inf') and float('-inf')
or
# Use maximal system integer to represent infinity
INF = sys.maxsize

------------------------------------------------------------------------------
copy one list to another without iteration:~
	mylist[:] = s

copy a dictionary~
	x = {}
	x.copy()
	or
	y = dict(x)

------------------------------------------------------------------------------
Iterator raises StopIteration exception when next(iter) fails.~

list.count(val) counts (not itertools.count() which does something different)
p.283

------------------------------------------------------------------------------
check list or deque x is empty:~
if not x:
    print('list/deque is empty')

------------------------------------------------------------------------------
bisect() can be implemented as a while loop (instead of recursion).~
Same logic as recursion.
p.35

------------------------------------------------------------------------------
ValueError and TypeError are 2 exceptions you can use in your code.~

------------------------------------------------------------------------------
It is safe to do [None] * 3 to get a list of length 3. Items are _independent_.~

List initialization No No:~
You should not do [[]] * 3 because the inside [] is the same for all 3 items
since only the reference to [] is copied 3 times. (Instead use list
comprehension).

Following is OK:

To get a 3x2 matrix:
A = [None] * 3
for i in range(3):
    A[i] = [None] * 2
or
w, h = 2, 3
A = [[None] * w for i in range(h)]
See ~/help/python

------------------------------------------------------------------------------
To get pairwise elements use itertools.pairwise()~
def pairwise(iterable):
    # pairwise('ABCDEFG') --> AB BC CD DE EF FG
Alternately:
for x, y in zip(a, a[1:]):
  print(x, y)
ex:
return '' if any(i == j for i, j in pairwise(res)) else ''.join(res)

itertools.groupby() gotchas:~
- to simply get a hashmap of counts of each element use collections.Counter()
- You must sort the list first before passing to groupby()
- The iterator returns a tuple, first is the element, second is a list of all
  occurances of that element.
- You can only use that iterator once. If you need to sort your grouped list by
  count you should store the list first.
        s = 'asaaaddfafff'
        groups = [(ch, len(list(lst))) for ch, lst in groupby(sorted(s))]
        groups = sorted(groups, key=lambda x: x[1], reverse=True)
- There is only one iterator underneath. You can only traverse the sublist once.
  So if you calculating the length of sublists, do it only once (after
  converting the iterator to a list)
        for n, lst in groupby(sorted(nums)):
            sublistlen = len(list(lst))

Blurb from library doc:~
The operation of groupby() is similar to the uniq filter in Unix. It generates
a break or new group every time the value of the key function changes (which is
why it is usually necessary to have sorted the data using the same key
function). That behavior differs from SQL’s GROUP BY which aggregates common
elements regardless of their input order.

The returned group is itself an iterator that shares the underlying iterable
with groupby(). Because the source is shared, when the groupby() object is
advanced, the previous group is no longer visible. So, if that data is needed
later, it should be stored as a list:
>
	groups = []
	uniquekeys = []
	data = sorted(data, key=keyfunc)
	# can be: for k, g in groupby(data, lambda x: x[0]):
	for k, g in groupby(data, keyfunc):
	    groups.append(list(g))      # Store group iterator as a list
	    uniquekeys.append(k)

p.767

------------------------------------------------------------------------------
How to get unique values in list?~
x = list(set(x))

Gotcha: reverse() and sort() on list do not return value.~
mylist = mylist.sort()  <- SILENT ERROR
mylist = mylist.reverse()  <- SILENT ERROR

Gotcha: reversed(), sorted() do not return a list, but they return iterator object.~
Doing len() on these things is an ERROR

for ...:
    ...
    break
else:
    # executed when break does not trigger

------------------------------------------------------------------------------
How to skip next few iteration steps inside a for loop:~
1) if you know the condition apriori you can use a generator expression:
  for i in (x for x in range(10) if x != 2):
2) If condition can only be determined during execution of for loop, you have
  to store the iterator object, call next() on it by using a iterator object
  obtained through islice().

from itertools import islice
numbers = iter(range(10))
for i in numbers:
    if i == 2:
        next(islice(numbers, 3, 3), None)  # consume 3

next(iterator)
next(iterator, default)
Retrieve the next item from the iterator by calling its __next__() method. If
default is given, it is returned if the iterator is exhausted, otherwise
StopIteration is raised.

itertools.islice(iterable, stop)
itertools.islice(iterable, start, stop[, step])
Make an iterator that returns selected elements from the iterable. If start is
non-zero, then elements from the iterable are skipped until start is reached.
Afterward, elements are returned consecutively unless step is set higher than
one which results in items being skipped. If stop is None, then iteration
continues until the iterator is exhausted.

------------------------------------------------------------------------------
How to get number of elements (length) of iterator?~
Say you don't want to build a list, then you can do:
>>> mylen = sum(1 for _ in range(10))

But iterator will be exhausted after use.
Use a lambda expression to create a generator expression.
foo = lambda : (x for x in ...)
Don't forget to put () after foo(), when using foo().

------------------------------------------------------------------------------
If you enumerate revesed lists, your indices will be reversed (0 would be last element):~
        for i, d in enumerate(digits[::-1]):

------------------------------------------------------------------------------
print(*iterator) will print because '*' will unpack the iterator values into
positional arguments for print().

------------------------------------------------------------------------------
Do not use append() or extend() inside list comprehension.~
It returns [None, ...] because append returns None.

>>> z
Out[16]: [[5, 3, 99], [2, 3, 99]]

>>> zz = [f.copy().append(9339) for f in z]

>>> zz
Out[19]: [None, None]

Use list concatenation instead (using '+')
      ptos.extend(x + [pl] * n for x in copy.deepcopy(bval))

------------------------------------------------------------------------------
Use copy.deepcopy() when you copy 2-D lists (see above example)~

'copy' from standard library:

Assignment statements in Python do not copy objects, they create bindings
between a target and an object.

Interface summary:

import copy

copy.copy(x)
Return a shallow copy of x.
(there is also list.copy())

copy.deepcopy(x[, memo])
Return a deep copy of x.

------------------------------------------------------------------------------
All functions return something. If you don't specify anything it will return a
None object.

------------------------------------------------------------------------------
C like structs:~
The idiomatic approach is to use dataclasses for this purpose. 'namedtuple' is
non-modifiable since it is a tuple. If you want to assign values to fields you
have to use dataclasses or classes.
>
    from dataclasses import dataclass
    @dataclass
    class Employee:
        name: str = None  # default argument
        dept: str
        salary: int

This style of access is clear, concise, and convenient.

>>> john = Employee('john', 'computer lab', 1000)
>>> john.dept
'computer lab'

Can add methods:~
>
	@dataclass(frozen=True)
	class Pos:
	    row: int
	    col: int
	    def __add__(self, other):
	        return Pos(row=self.row + other.row, col=self.col + other.col)
	    def __lt__(self, other):
	        return True

------------------------------------------------------------------------------
Inheritance: super() is very different than in Java.~
super() alone returns a temporary object of the superclass that then allows you
to call that superclass’s methods. It does NOT take any arguments.
From child object you call parent's method using explicit method name:
super().writefoo(args)

------------------------------------------------------------------------------
__init__() vs __new__()~
__new__ is a static method, while __init__ is an instance method. __new__ is
responsible for creating and returning a new instance, while __init__ is
responsible for initializing the attributes of the newly created object.
__new__ is called before __init__ .

------------------------------------------------------------------------------
No need to declare variable inside a function.~
Variables first declared in if or for statements are visible outside.
Everything is function scope, class scope, module scope, etc.
def fn():
    if xxx:
        y = some()
    return y

------------------------------------------------------------------------------
Whether to use self.fn() or super().fn() in a child class where only parent
defines fn():
The most common assumption is that you'd want to be able to override fn in a
subclass, so for most use-cases, you'd stick with self.fn().

------------------------------------------------------------------------------
remove last element from list~
foo[:-1]
del foo[-1]
foo.pop()

------------------------------------------------------------------------------
Possible to sort array in LINEAR time.~
If you use a giant array and simply flag indices where numbers in original
array exist, and collect all those flagged indices, you have sorted in linear
time. This is 'bucket sort'.
p347

Flatten lists:~
- use recoursion for n-dimensional lists
- use itertools.chain()
- use list comprehension.

Flatten list~
>
	>>> a = [[1, 2], [3, 4], [5, 6]]
	>>> list(itertools.chain.from_iterable(a))
	[1, 2, 3, 4, 5, 6]

p.1615

Interpreting nested for loops in list comprehension:~
Interpret the following as:

<num <for elem in vec> for num in elem>

Inside for loop is the outer loop when translated:

for elem in vec:
    for num in elem:
        ...

> vec = [[1,2,3], [4,5,6], [7,8,9]]
> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]

------------------------------------------------------------------------------
Variable created in 'for' loop is not accessible from outside the loop.~
Soln: use 'else' clause

        for ss in s:
            for tt in range(tidx, len(t)):
                if t[tt] == ss:
                    tidx = tt + 1
                    break
            # tt is NOT available here!
            else:
                return False
p392

------------------------------------------------------------------------------
Scope of variables~

- Scope is nothing but a dictionary.
- Every function has its own local dictionary (for scoping)
- Module has its own dictionary
- Classes and methods have theirs
- There is a outermost dictionary for builtin names
- A function can use its own local dictionary and the outermost dictionary

At any time during execution, there are 3 or 4 nested scopes whose namespaces
are directly accessible:
- the innermost scope, which is searched first, contains the local names
- the scopes of any enclosing functions, which are searched starting with the
  nearest enclosing scope, contain non-local, but also non-global names
- the next-to-last scope contains the current module’s global names
- the outermost scope (searched last) is the namespace containing built-in
  names
>
	def foo(arg):
	    innerarg = 4
	    def bar():
	        innerarg = 2 # OK, innerarg is created in bar() scope.
	        print(innerarg)
	        arg += 'notxx' # NOT Ok (1)
	        print(arg)
	    bar()
	(1) arg = arg + 'notxx' => it creates 'arg' in bar() namespace. Since
	arg is not assigned to any value, you get UnboundLocalError.

	def foo(arg):
	    innerarg = 4
	    def bar():
	        print(innerarg) # OK, it finds innerarg in outer scope.
	        arg = 3 # OK, since this is declaration of arg in bar() scope
	        print(arg)
	    bar()

- 'nonlocal' binds local variables to immediate outer scope.
- 'global' binds variables to module (file) scope (NOT to outermost scope
where builtin names live).
- when you use 'nonlocal' it is same as having a local variable that has
reference to another variable of the same name in outer scope. They are NOT
SAME variable. If you reassign to inner x (say x = x[2:]), it is not reflected
in outer scope. Slicing mutates objects. Variable x gets assigned to a new
array x[2:].
- integers, float, etc. are pass-by-value, and so a 'nonlocal' inner variable
and outer variable refer to the same thing (you can change values).

Print address of a variable~
Use id(). Can combine with hex().

	print(hex(id(foo))
p.4

------------------------------------------------------------------------------
'Not defined' not same as 'None'
if not xxx:
         print('foo')
Above will give NameError if xxx was not defined.
NameError: name 'xxx' is not defined

To check if defined, see existence in locals().

------------------------------------------------------------------------------
set, dict are in stdtypes.txt
do |set..stdtypes.txt|

set"extend" is through union operator "|". Synonymously you can use set.update()
You can add a list, but only after converting to set.
>
	s |= set([1, 4, 54])

set has "add" instead of "append". add() only adds one element.

------------------------------------------------------------------------------
How to distinguish between None and 0/False? ~
if x is not None:
    ...
x = False
if x: # false
if x is not None: # true

x is not None
is equivalent to
id(test) == id(None) #False

------------------------------------------------------------------------------
Check existence of local/global/instance variable ~
Local var:
if 'myVar' in locals():
  # myVar exists.

To check the existence of a global variable:
if 'myVar' in globals():
  # myVar exists.

To check if an object has an attribute:
if hasattr(obj, 'attr_name'):
  # obj.attr_name exists.

------------------------------------------------------------------------------
Sliding Window and DP~
An alternative to recursive solution if you can ask the question "can I say it
is valid now because it is valid for some small window (of X elements) I can
examine now, and it was valid for f(N-X) state that you just traversed before?" 
Now you can iterate with a DP array and find solution.
p.2369

------------------------------------------------------------------------------
Interleave the 2 linked lists if you are copying~
This turns O(nxn) solution to O(n)
This solves problems related to deep copying random pointers

Cannot guarantee order of execution when you create tuple and unpack~
            jt = it.next
            it = jt.next
is not the same as
	jt, it = it.next, jt.next
p.138

------------------------------------------------------------------------------
Are objects of user defined hashable? YES~

Objects which are instances of the user-defined class are hashable by default,
they all compare unequal, and their hash value is their id().

All immutable built-in objects in Python are hashable like tuples while the
mutable containers like lists and dictionaries are not hashable.

------------------------------------------------------------------------------
In linked list problems think of keeping 2 pointers n spaces apart~

You can solve problems with 1 loop traversal instead of two.
p.19

Anonymous objects/classes are not a thing in python~
Use namedtuples or dataclasses (@dataclass).

namedtuples are like tuples, you can iterate through them.

Add a plus/add method to a namedtuple:~
>
	from operator import add
	class Point(namedtuple("Point", "x y")):
	    def __add__(self, other):
	        return Point(*map(add, self, other))

------------------------------------------------------------------------------
Use `y = max(x, y)` instead of `if x > y: y = x`

max() and min() accept 'key' which can be a lambda:
Say we have dict called counter.
>
     return max(counter.items(), key=lambda x: x[1])

------------------------------------------------------------------------------
Shifting array~

The best way to shift an arry to left (remove 1 element from beginning and add
another at end) is to use a deque() and do popleft() and append().
p.198

------------------------------------------------------------------------------
In a dict() or set(), items(), keys(), values() are just views~

When you delete from dict (del mydict[key]) then items(), keys(), values()
all change automatically. These are not copies but views.

------------------------------------------------------------------------------
Make a dictionary of frequencies from list of values~
>
	>>> collections.Counter([1, 2, 2])
	Counter({2: 2, 1: 1})

A "Counter" is a "dict" subclass for counting _hashable_ objects.
  It is a collection where elements are stored as dictionary keys and
  their counts are stored as dictionary values.

------------------------------------------------------------------------------
List subscript ~ vs -: ~

i = 3
a[~i] is 4th element from the end (matches a[i] which is 4th element from the
beginning).
a[-i] is 3rd element from the end.

------------------------------------------------------------------------------
assert statement~

assert y!=0, "y cannot be zero"
assert condition [, Error Message] 

------------------------------------------------------------------------------
Slice and reverse list~

a[i:j+1][::-1]

Cannot compare List reversed()~

return a[i:j] == reversed(a[i:j]) is always False because reversed() return a
'reversed' object. RHS is not a list.
Use a[i:j] == a[i:j][::-1]

=============================================================================
DP problems:~

The key to solving a DP problem efficiently is finding a way to break the
problem into subproblems such that
- the original problem can be solved relatively easily once solutions to the
  subproblems are available, and
- these subproblem solutions are cached.

Focus on breaking down the problem in terms of F(n) = F(n-x) + ...
Don’t have to do divide and conquer (break it in the middle).
If you can find above relation, you may do DP

READ THE VARIANTS of these problems in the EPI book.

1) Use 2D array
Count the NUMBER of score combinatrons
In an American football game, a play can lead to 2 points (safety), 3 points
(field goal), or 7 points (touchdown, assuming the extra point). Many different
combinations of 2,3, and 7 point plays can make up a final score. For example,
four combinations of plays yield a score of 12:
o 6 safeties (2x6=12),
o 3 safeties and 2 field goals (2 x 3 + 3 x2 = 72),
o 1 safety,l field goal and l touchdown (2 x 1+ 3 x 1 +7 x1= 12), and
o 4 fieldgoals(3x4=12).
Write a program that takes a final score and scores for individual plays, and
retums the number of combinations of plays that result in the final score.

Hint: Count the number of combinations in which there are 0, 1, 2, 3 points
from only safety, then repeat for (safety and field goal), etc.

O pts column is initialized to 1's.
2nd row: You can use 3 once, twice, etc. See the balance required and check
previous row. Add it all up.

		0 	1 	2 	3 	4 	5 	6 ...
(2) 		1 	0 	1 	0 	1 	0 	1
(2,3) 		1 	0 	1 	1 	1 	1 	1+1
(2,3,7) 	1 	0 	1 	1 	1 	1 	2

DP table lor 2,3,7 point plays (rows) and final scores from 0 to L2 (columns).

2) Compute Levenshtein Distance between 2 strings (for spell check)
Levenshtein defined the distance between two words as the minimum number of
"edits" it would take to transform the misspelled word into a correct word,
where a single edit is the insertion, deletion, or substitution of a single
character.

Soln: Use 2 2-D matrix (Carthorse -> Orchestra)

	 	C 	a 	r 	t 	h 	o 	r 	s 	e
	0 	1 	2 	3 	4 	5 	6 	7 	8 	9
O 	1 	1 	2 	3 	4 	5 	6 	7 	8 	9
r 	2 	2 	2 	2 	3 	4 	5 	6 	7 	8
c 	3 	3 	3 	3 	3 	4 	5 	6 	7 	8
...

- first row and column is when you transform to empty string
- Say index (2,4) (value=3). t col and r row. Asks how to transform 'Cart' to 'Or'.
- You are taking min of item to left (delete last letter from 'Cart'), item
  above (do the same for 'Or') and item diagonally left-above (replace last
  letter of both words)
- bottom right cell gives the answer.

------------------------------------------------------------------------------
Voting algo~
Keep track of majority element (occurs > n/2 times, n=size)
>
    def majorityElement(self, nums: List[int]) -> int:
        # voting algo
        count = 0
        for n in nums:
            if not count:
                candidate, count = n, 1
            else:
                count += 1 if candidate == n else -1
        return candidate

------------------------------------------------------------------------------
Python match-case statement (like switch statment)~
>
	my_value = 10
	chosen_color = 11
	match my_value:
	    case 10:
	        print("The number is ten")
	    case base_color: # XXX see below
		print("Yes, it matches!")
	    case _:
	        # this is the default handler if none
	        # of the above cases match.
	        print("The number is none of 10, 2*10 or 100")

Important Notes:

- Cases don't fall through. It is like having a 'break' inside every 'case'.
- Variable references don't work as a condition. Why you can't match single
  variable references in case conditions: you don't actually match against the
  value of that variable but actually introduce a placeholder of that same name! 
- Unfortunately, it is not a regex match. You cannot do `case r'foo':`
- Powerful Pattern Matching (match - (M)atch (a)in'(t) (c)ase (h)ooey)
  It features special functionality like deep placeholders and wildcards.
>
	match point:
	    case (0, 0):
	        print("Origin")
	    case (0, y):
	        print("Our current Y position is", y, " now.")

You can match arbitrary nested data structures, including placeholders. In the
above example, we are matching a tuple with two items where in the second
case, we use a placeholder y that gets its value assigned upon matching.

You can also match class attributes, in a very similar fashion:
>
	class Point:
	    x: int
	    y: int
	
	def location(point):
	    match point:
	        case Point(x=0, y=0):
	            print("Origin is the point's location.")
	        case Point(x=0, y=y):
	            print("The point lies on the y axis at a height of", y, "units.")


------------------------------------------------------------------------------
Enum~
>
	from enum import Enum
	
	# class syntax
	class Color(Enum):
	    RED = 1
	    GREEN = 2
	    BLUE = 3
	
	# functional syntax
	Color = Enum('Color', ['RED', 'GREEN', 'BLUE'])
	
	>>> Color.BLUE.name
	'BLUE'
	# values start from 1
	>>> Color.RED.value
	1
	>>> dir(Color)
	['BLUE', 'GREEN', 'RED', '__class__', '__contains__', '__doc__', '__getitem__', '__init_subclass__', '__iter__', '__len__', '__members__', '__module__', '__name__', '__qualname__']
	>>> Color['BLUE']
	<Color.BLUE: 3>
	>>> list(Color)
	[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 3>]
	>>> len(Color)
	3


Even though we can use class syntax to create Enums, Enums are not normal
Python classes.
- The class Color is an enumeration (or enum)
- The attributes Color.RED, Color.GREEN, etc., are enumeration members (or
  members) and are functionally constants.
- The enum members have names and values (the name of Color.RED is RED, the
  value of Color.BLUE is 3, etc.)


------------------------------------------------------------------------------
pep8: E731 do not assign a lambda expression, use a def~
>
	Yes:
	def f(x): return 2*x 

	No:
	f = lambda x: 2*x 

The legitimate use case for lambda is where you want to use a function without
assigning it, e.g:
>
	sorted(players, key=lambda player: player.rank)

Assigning lambdas to names basically just duplicates the functionality of def
- and in general, it's best to do something a single way to avoid confusion
and increase clarity. The first form means that the name of the resulting
function object is specifically 'f' instead of the generic '<lambda>'. This is
more useful for tracebacks and string representations in general. Do not make
reducing number of LoC a goal. Go for clarity.

------------------------------------------------------------------------------
Cartesian product for graph problems and such~
|product()..itertools.pyx|

   Roughly equivalent to nested for-loops in a generator expression.
   For example, "product(A, B)" returns the same as "((x,y) for x in A
   for y in B)".

          # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
          # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111

example
>
	for leftTree, rightTree in product(getTreeList(nodes[:i]), getTreeList(nodes[i+1:])):
		...

------------------------------------------------------------------------------
Memoization with @cache decorator~
|cache()..functools.pyx|
Can use `@cache` or `@functools.cache`
>
	@cache
	def factorial(n):
	    return n * factorial(n-1) if n else 1

	>>> factorial(10)      # no previously cached result, makes 11 recursive calls
	3628800
	>>> factorial(5)       # just looks up cached value result
	120
	>>> factorial(12)      # makes two new recursive calls, the other 10 are cached
	479001600


------------------------------------------------------------------------------
C's Static variable like functionality~
|cached_property()..functools.pyx|

See @functools.cached_property(func)

Transform a method of a class into a property whose value is computed once and
then cached as a normal attribute for the life of the instance. 

------------------------------------------------------------------------------
Can you modify variable inside a for/while loop?~

If you use range() it calculates the range through a generator. Changing loop
variable has no effect. It gets overridden when next iteration begins.
>
	for j in range(len(grid[0])):
		j += 1 # DOES NOT WORK

	while j < len(somelist):
		somelist.insert(y, element)
		y += 1 # OK, len(somelist) is calculated every iteration

------------------------------------------------------------------------------
heap~
>
	import heapq
        heap = []
	heapq.heappush(heap, val)
        while heap:
            val = heapq.heappop(heap)

------------------------------------------------------------------------------
any() all() sum() with generator~

If any(generator) does not yield correct result, it is because the generator
is _exhausted_. Generator can be iterated ONLY ONCE. So instead use a list()
or use a lambda expression to create new generator on demand.

------------------------------------------------------------------------------
binary search and bisect~

bisect.bisect_left(a, x, ...) returns index ip where x < a[0:ip]
   The returned insertion point _ip_ partitions the array _a_ into two
   slices such that "all(elem < x for elem in a[lo : ip])" is true for
   the left slice and "all(elem >= x for elem in a[ip : hi])" is true
   for the right slice.
bisect.bisect_right(a, x, ...) returns index ip (insertion pt) where x < a[0:ip - 1]
   The returned insertion point _ip_ partitions the array _a_ into two
   slices such that "all(elem <= x for elem in a[lo : ip])" is true
   for the left slice and "all(elem > x for elem in a[ip : hi])" is
   true for the right slice.
insertion point (ip) returned is either to left or right of where insertion
should happen

------------------------------------------------------------------------------
Find the first occurance of element in list using a key function~

`list.index()` does not take a key input. It is not useful here. Use `next()`
with a generator (a [] instead of () is going to be way slower):
https://stackoverflow.com/questions/9868653/find-first-sequence-item-that-matches-a-criterion)
You can use a default value so it does not throw StopIteration exception if
element is not present.
>
	x = next((obj for obj in objs if obj.val == 5), None)
	x = next((i, obj for i, obj in enumerate(objs) if obj.val == 5), None)
	if x:
	    pass # do something

`next(iterator, default)`:
   Retrieve the next item from the _iterator_ by calling its
   "__next__()" method.  If _default_ is given, it is returned if the
   iterator is exhausted, otherwise "StopIteration" is raised.

------------------------------------------------------------------------------
debug~
Use dir(obj), id(obj), class(obj)

------------------------------------------------------------------------------
eval()~
Don't forget to copy the dict. Otherwise, after eval() it gets populated with
__builtins__.
	>>> x = {'s': 14, 'm': 33}
	>>> res = eval('s<20', x.copy())
	>>> True

------------------------------------------------------------------------------
No do-while loop, but~

while True:
  stuff()
  if fail_condition:
    break

------------------------------------------------------------------------------
Do not use variables named 'I', 'O', or 'l' (E741)~
Variables named I, O, and l can be very hard to read. This is because the
letter I and the letter l are easily confused, and the letter O and the number
0 can be easily confused.

------------------------------------------------------------------------------ 
single tuple inside a tuple trick~
((0, 3)) does not give you a tuple of (0, 3). Instead do ((0, 3),)
Documented in python tutorial.

------------------------------------------------------------------------------ 
Increase recursion stack size~
	import sys
	sys.setrecursionlimit(100000)

------------------------------------------------------------------------------ 
defaultdict~

graph = collections.defaultdict(set)
for match in matches:
	graph[match.winning_team].add(match.losing_team)

Empty set() is the default value for any inserted key, val pair.

------------------------------------------------------------------------------
replace nested loops with itertools.product()~

	for v, p, t in itertools.product(verbs, persons, tenses):
		...

replaces

	for v in verbs:
	    for p in persons:
		for t in tenses:
		    return [v, p, t]
------------------------------------------------------------------------------
python function objects are closures~

Function objects in Python aren't just functions, they're closures:1 they
carry around a reference to the local environment where the def statement was
executed.

In particular, local variables from inside outer_func can be accessed from
inside inner_func. (Even if you return inner_func, those values are kept alive
so the closure will still work, for as long as inner_func is alive.)

If you add a nonlocal statement inside inner_func, it can even reassign the
local variables from the body of outer_func.

How does this work?

Well, a def statement is just a statement, like any other. What it does is
something like this:

inner_func = _make_closure(<code from compiling inner_func body>, locals())

That <code from compiling inner_func body> is actually a constant value—the
compiler compiles the body of every function in your module into constant code
objects at import time.

But the function object that comes back from that _make_closure is a new thing
that's created on the fly, and it has a reference to the local variables baked
into it. Every time you run outer_func, it creates a new inner_func closure
from the same <code>, each one capturing the current local environment.
>
	def outer_func(pa=1, pb=2):
	    def inner_func():
	        print(pa)
	    print(type(inner_func))
	    another_func(inner_func)

See the 'inspect' module's docs, which show you how to find things like
__closure__ and co_freevars in your interactive interpreter, and the dis
module which lets you look at the actual bytecode that your functions get
compiled to.

https://stackoverflow.com/questions/51550211/how-do-variables-from-an-outer-scope-get-evaluated-in-nested-functions

You seem to be confusing the code if the function with the function object.
The code object is evaluated only once, when the source file is read. However,
a new function object called inner_func is created every time outer_func is
called. This happens because a def statement is a type of assignment: it
associates a function object with the specified name.

So the value of pa in inner_func is going to be whatever it is in outer_func
at the time of calling.

------------------------------------------------------------------------------
Can declare nested function with same name but different signature~
>
	class Solution:
	    def maxSubArray(self, nums):
	        def maxSubArray(A, L, R):

------------------------------------------------------------------------------
Interleave two lists~
use chain() wit *zip() or *zip_longest()
>
        memo = list(chain(*zip_longest(sums, (nums[i] for i in idxs))))
	nums: [-2, 1, -3, 4, -1, 2, 1, -5, 4]
	sums: [0, 1, 4, 3, 4]
	idxs: [0, 2, 4, 7]
	memo: [0, -2, 1, -3, 4, -1, 3, -5, 4, None]

or use slice syntax (slice creates a view of underlying list, not a copy)
>
	>>> a = [0, 2, 4, 6, 8]
	>>> b = [1, 3, 5, 7, 9]
	>>> c = a + b # just to create a list of correct size
	>>> c[::2] = a
	>>> c[1::2] = b
	>>> c
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

------------------------------------------------------------------------------
Alternative for splitting a list~
>
	good = [x for x in mylist if x in goodvals]
	bad = [x for x in mylist if x not in goodvals]

	can be replaced with (less readable):

	good, bad = [], []
	for x in mylist:
	    (bad, good)[x in goodvals].append(x)

------------------------------------------------------------------------------
Slice a list until certain condition is met~
use takewhile() and dropwhile()
>
          # takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4
          # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

------------------------------------------------------------------------------ 


vim:tw=78:ts=8:ft=help:norl:set modifiable noreadonly:
