*leetcode-cpp.txt*

------------------------------------------------------------------------------
User kmjp's solutions:

Contest 291

typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
//-------------------------------------------------------


class Solution {
public:
    string removeDigit(string number, char digit) {
        string Z="";
        int i;
        FOR(i,number.size()) {
            if(number[i]==digit) {
                string S=number.substr(0,i)+number.substr(i+1);
                if(Z=="") {
                    Z=S;
                }
                else {  // separate line so that whole block can be deleted
                    Z=max(Z,S);  // giri: Z and S are strings with numbers, int-value comparison is valid
                }
            }
        }
        return Z;
    }
};

class Solution {
public:
    int minimumCardPickup(vector<int>& cards) {
        map<int,int> P;
        int i;
        int mi=1<<20;  // a 'inf' value
        FOR(i,cards.size()) {
            if(P.count(cards[i])) mi=min(mi,i-P[cards[i]]+1);  // count() returns 0 or 1
            P[cards[i]]=i;
        }

        if(mi==1<<20) mi=-1;
        return mi;
    }
};

class Solution {
public:
    int countDistinct(vector<int>& nums, int k, int p) {
        vector<vector<int>> R[202];  // max length of 'nums' argument is 200, use of 2-d array to speed up
        int i,j;  // he declares these because 'FOR' needs this
        FOR(i,nums.size()) {
            int ng=0;
            vector<int> V;
            for(j=i;j<nums.size();j++) {
                if(nums[j]%p==0) ng++;  // no need to use {} block, no spaces
                if(ng>k) break;
                V.push_back(nums[j]);
                R[V.size()].push_back(V);
            }
        }

        int ret=0;
        FOR(i,202) if(R[i].size()) {  // not empty
            ret++;
            sort(ALL(R[i]));  // sort from beg to end
            for(j=1;j<R[i].size();j++) if(R[i][j]!=R[i][j-1]) ret++;
        }
        return ret;

    }
};


int C[26];
class Solution {
public:
    long long appealSum(string s) {
		int C[26]={}; // 0 initialized array
		ll ret=0;
		int i,j;
		FOR(i,s.size()) {
			C[s[i]-'a']=i+1;
			FOR(j,26) ret+=C[j];
		}
		
        return ret;
    }
};

from penguinhacker (last solution): (no macros)

class Solution {
public:
    long long appealSum(string s) {
        vector<int> last(26, -1);
        long long ans=0;
        for (int i=0; i<s.size(); ++i) {
            last[s[i]-'a']=i;
            for (int j=0; j<26; ++j)
                if (last[j]!=-1)
                    ans+=last[j]+1;
        }
        return ans;
    }
};
------------------------------------------------------------------------------
7.6 in EPI C++: convert a single char to a std::string

to convert a single char to a std::string do std::string(1, ch), where 1 is
size of string in constructor.

can also do: ch + some_str

------------------------------------------------------------------------------
If you end up with a problem which involves never ending nested for loops, use recursion.
for ..
  for ...
    for ...

------------------------------------------------------------------------------
Anytime you repeat even small snippets of code, like a if() statement
containing complicated checks, think of lambda function.

------------------------------------------------------------------------------
There are 2 type of linked list problems:
1) you have to implement linked list yourself
  - use a dummy head to keep track of empty list
2) using library
  - list() class is a doubly linked list, forward_list is singly linked.
  - [push|emplace|pop]_[front|back], reverse, sort, splice(L1.end(), L2) to transfer elements
  - for forward_list: insert_after(L1.end(), x), emplace_after(), splice_after()
  - *max_element(mylist.begin(), mylist.end()) gives max element in the list

template<typename T>
struct ListNode {
  T data;
  // use shared_ptr since 2 nodes can point to same element in a circular list
  shared_ptr<ListNode<T>> next;
  // in destructor check reference count of next == 1 (next.use_count() == 1) before resetting (next= next->reset()) 
}

bool operator==(const ListNode<T>& that) const {
▏ ▏ const ListNode<T>* a = this;
▏ ▏ const ListNode<T>* b = &that;
▏ ▏ while (a && b) {
▏ ▏ ▏ if (a->data != b->data) {
▏ ▏ ▏ ▏ return false;
▏ ▏ ▏ }
▏ ▏ ▏ a = a->next.get();
▏ ▏ ▏ b = b->next.get();
▏ ▏ }
▏ ▏ return a == nullptr && b == nullptr;
}

use make_shared:
head = std::make_shared<ListNode<T>>(*it, head);

------------------------------------------------------------------------------
use a std::set to keep track of visited nodes:
<< operator needs std::ostream
template <typename T>
  std::ostream& operator<<(std::ostream& out, shared_ptr<ListNode<T>> node) {
  ▏ std::set<shared_ptr<ListNode<T>>> visited;
  ...
}

------------------------------------------------------------------------------
can use nullptr and get() (see below for get()):

bool operator==(const ListNode<T>& that) const {
▏ const ListNode<T>* a = this;
▏ const ListNode<T>* b = &that;
▏ while (a && b) {
▏ ▏ if (a->data != b->data) {
▏ ▏ ▏ return false;
▏ ▏ }
▏ ▏ a = a->next.get();
▏ ▏ b = b->next.get();
▏ }
▏ return a == nullptr && b == nullptr;
}

------------------------------------------------------------------------------
Avoid using variable names with underscore. They are a pain to type if you also
have another variable with same beginning.

------------------------------------------------------------------------------
std::stack()

push, emplace, top, pop, empty

when called on empty stack top() and pop() throw exceptions

Implement a stack with max() operation:
Keep a variable for every entry in stack that contains max value if that
entry gets popped off.

------------------------------------------------------------------------------
To check if parenthesis of various types are correctly written in a code (matched).
or
remove extreneous .. and . from long pathnames (shrink pathname to minimum)

use a stack.


------------------------------------------------------------------------------
Implement your own binary tree:

template <typename T>
struct BinaryTreeNode {
  T data;
  unique_ptr<BinaryTreeNode<T>> left, right;
  
  explicit BinaryTreeNode(const T& data) : data(data) {}
  BinaryTreeNode(T data, unique_ptr<BinaryTreeNode<T>> left,
                 unique_ptr<BinaryTreeNode<T>> right)
      : data(data), left(std::move(left)), right(std::move(right)) {}
};

------------------------------------------------------------------------------
REVERSE ALL WORDS IN A SENTENCE

"  Alice loves John" should yield "John loves Alice  "

I did the hard way. It is intricate to iterate on words and place them in
reverse order, even into a different string. This is because of leading and
trailing spaces.

Better would be to reverse the whole string letter by letter (use
std::reverse), and then simply reverse the letters inside each world
separately.

------------------------------------------------------------------------------
Instead of:

  bool negative = (num1.front() < 0 && num2.front() > 0) ||
                  (num1.front() > 0 && num2.front() < 0);
do:
  const int sign = num1.front() < 0 ^ num2.front() < 0 ? -1 : 1;

------------------------------------------------------------------------------ 
For long 64bit shifting use:

x=(1L << i);
do not use 1 << i, it only shifts 32 bits.

0u says unsigned

------------------------------------------------------------------------------
 fastest way to reverse bits is to build a precomputed array
 precompute_reverse such that for every16-bitnumber i, precompute_reverse[i]
 holds the bit-reversed i

------------------------------------------------------------------------------
to convert a digit 5 to char, do '0' + 5
to do reverse use ch - '0' or use std::isdigit()

for multiple digits use std::atoi(std::c_str()) or C atoi(str::c_str())

------------------------------------------------------------------------------
vim:tw=78:ts=8:ft=help:norl:set modifiable noreadonly:
