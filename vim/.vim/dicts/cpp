--- NOTE: Keep words short, otherwise info popup window will have no space.
---  Keep exactly 4 spaces at the beginning of line to parse line as 'info' popup content

--- useful shortcuts
vector<int>
vector<
vector<vector<int>>
vector<vector<
vector<char>
vector<string>
string
set<int>
set<
map<
unordered_map<
pair<int, int>
first
second

--- from cppreference.com
--- keywords
alignas
alignof
and
and_eq
asm
atomic_cancel
atomic_commit
atomic_noexcept
auto
bitand
bitor
bool
break;
case
catch
char
char8_t
char16_t
char32_t
class
compl
concept
const
consteval
constexpr
constinit
const_cast
continue;
co_await
co_return
co_yield
decltype
default
delete
do
double
dynamic_cast
else
enum
explicit
export
extern
false
float
for(
friend
goto
if(
inline
int
long
mutable
namespace
new
noexcept
not
not_eq
nullptr
operator
or
or_eq
private
protected
public
reflexpr
register
reinterpret_cast
requires
return
short
signed
sizeof
static
static_assert
static_cast
struct
switch
synchronized
template
this
thread_local
throw
true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchar_t
while(
xor
xor_eq
final
override
transaction_safe
transaction_safe_dynamic
import
module
--- memory management
unique_ptr
shared_ptr
weak_ptr
--- vector
front()
back()
data()
begin()
cbegin()
end()
cend()
rbegin()
crbegin()
rend()
crend()
empty()
size()
max_size()
reserve(
capacity(
shrink_to_fit()
clear()
insert(
insert_range(
emplace(
erase()
push_back(
emplace_back(
append_range(
pop_back(
resize(
swap(

vector::
    The elements are stored contiguously.

    operator= -> assigns values to the container
    assign -> assigns values to the container
    assign_range -> assigns a range of values to the container
    get_allocator -> returns the associated allocator
    at -> access specified element with bounds checking
    operator[] -> access specified element
    front -> access the first element
    back -> access the last element
    data -> direct access to the underlying contiguous storage
    begin
    cbegin -> returns an iterator to the beginning
    end
    cend -> returns an iterator to the end
    rbegin
    crbegin -> returns a reverse iterator to the beginning
    rend
    crend -> returns a reverse iterator to the end

    Capacity
    empty -> checks whether the container is empty
    size -> returns the number of elements
    max_size -> returns the maximum possible number of elements
    reserve -> reserves storage
    capacity -> returns the number of elements that can be held in currently allocated storage
    shrink_to_fit -> reduces memory usage by freeing unused memory

    Modifiers
    clear -> clears the contents insert
    insert -> inserts elements
    insert_range -> inserts a range of elements
    emplace -> constructs element in-place
    erase -> erases elements
    push_back -> adds an element to the end
    emplace_back -> constructs an element in-place at the end
    append_range -> adds a range of elements to the end
    pop_back -> removes the last element
    resize -> changes the number of elements stored
    swap -> swaps the contents

    Non-member functions
    operator==
    operator!=
    operator<
    operator<=
    operator>
    operator>=
    operator<=> -> lexicographically compares the values of two vectors
    std::swap(std::vector) -> specializes the std::swap algorithm
    erase(std::vector)
    erase_if(std::vector) -> erases all elements satisfying specific criteria

    Example

    int main()
    {
        // Create a vector containing integers
        std::vector<int> v = {8, 4, 5, 9};

        // Add two more integers to vector
        v.push_back(6);
        v.push_back(9);

        // Overwrite element at position 2
        v[2] = -1;

        // Print out the vector
        for (int n : v)
            std::cout << n << ' ';
        std::cout << '\n';
    }
    Output:

    8 4 -1 9 6 9

vector::vector
    int main()
    {
        // Create a vector containing integers
        std::vector<int> v = {8, 4, 5, 9};

        // Add two more integers to vector
        v.push_back(6);
        v.push_back(9);

        // Overwrite element at position 2
        v[2] = -1;

        // Print out the vector
        for (int n : v)
            std::cout << n << ' ';
        std::cout << '\n';
    }
    Output:

    8 4 -1 9 6 9

vector::assign
    assigns values to the container

vector::assign_range
    assigns a range of values to the container

vector::get_allocator
    returns the associated allocator

vector::at
    access specified element with bounds checking

vector::operator[]
    access specified element

vector::front
    access the first element

vector::back
    access the last element

vector::data
    direct access to the underlying contiguous storage

vector::begin

vector::cbegin
    returns an iterator to the beginning

vector::end

vector::cend
    returns an iterator to the end

vector::rbegin

vector::crbegin
    returns a reverse iterator to the beginning

vector::rend

vector::crend
    returns a reverse iterator to the end

vector::empty
    checks whether the container is empty

vector::size
    returns the number of elements

vector::max_size
    returns the maximum possible number of elements

vector::reserve
    reserves storage

vector::capacity
    returns the number of elements that can be held in currently allocated storage

vector::shrink_to_fit
    reduces memory usage by freeing unused memory

vector::clear
    clears the contents insert

vector::insert
    inserts elements

vector::insert_range
    inserts a range of elements

vector::emplace
    constructs element in-place

vector::erase
    erases elements

vector::push_back
    adds an element to the end

vector::emplace_back
    constructs an element in-place at the end

vector::append_range
    adds a range of elements to the end

vector::pop_back
    removes the last element

vector::resize
    changes the number of elements stored

vector::swap
    swaps the contents

vector:: operator==
    lexicographically compares the values of two vectors (non member fn)
vector:: operator!=
    lexicographically compares the values of two vectors (non member fn)
vector:: operator<
    lexicographically compares the values of two vectors (non member fn)
vector:: operator<=
    lexicographically compares the values of two vectors (non member fn)
vector:: operator>
    lexicographically compares the values of two vectors (non member fn)
vector:: operator>=
    lexicographically compares the values of two vectors (non member fn)
vector:: operator<=>
    lexicographically compares the values of two vectors (non member fn)
vector:: std::swap()
    specializes the std::swap algorithm
vector:: std::erase()
vector:: std::erase_if()
    erases all elements satisfying specific criteria

--- list and deque
push_front(
emplace_front(
prepend_range(
pop_front(
splice(
remove(
remove_if(
reverse(
unique(
sort(

list::
    Implemented as a doubly-linked list.

    operator= -> assigns values to the container
    assign() -> assigns values to the container
    assign_range() -> assigns a range of values to the
        container
    get_allocator() -> returns the associated allocator
    front() -> access the first element
    back() -> access the last element
    begin()
    cbegin()
    end()
    cend()
    rbegin()
    crbegin() -> returns a reverse iterator to the beginning
    rend()
    crend() -> returns a reverse iterator to the end()
    empty() -> checks whether the container is empty
    size() -> returns the number of elements
    max_size() -> returns the maximum possible number of
        elements
    clear() -> clears the contents
    insert() -> inserts elements
    insert_range() -> inserts a range of elements
    emplace() -> constructs element in-place
    erase() -> erases elements
    push_back() -> adds an element to the end
    emplace_back() -> constructs an element in-place at the
        end
    append_range() -> adds a range of elements to the end
    pop_back() -> removes the last element
    push_front() -> inserts an element to the beginning
    emplace_front() -> constructs an element in-place at the
        beginning
    prepend_range() -> adds a range of elements to the
        beginning
    pop_front() -> removes the first element
    resize() -> changes the number of elements stored
    swap() -> swaps the contents
    merge() -> merges two sorted lists
    splice() -> moves elements from another list
    remove() -> removes elements satisfying specific
        criteria
    remove_if() -> removes elements satisfying specific
        criteria
    reverse() -> reverses the order of the elements
    unique() -> removes consecutive duplicate elements
        (keeps the first)
    sort() -> sorts the elements

list::list
    std::list<int> l = {7, 5, 16, 8};
    l.push_back(13);
    l.push_front(25);
    std::list<int> c1(3, 100); // [100, 100, 100]

list::assign()
    std::list<char> characters;
    characters.assign(5, 'a'); // a a a a a
    const std::string extra(6, 'b');
    characters.assign(extra.begin(), extra.end()); // b b b b b b
    characters.assign({'C', '+', '+', '1', '1'}); // C + + 1 1

list::assign_range()
    auto source = std::vector{2, 7, 1};
    auto destination = std::list{3, 1, 4};
    destination.assign_range(source);

list::front()
    assert(letters.front() == 'a');
list::back()
    assert(letters.back() == 'd');
list::empty()
    returns bool
list::size()
    returns number (unsigned long, size_type)
list::clear()
    listx.clear()
list::insert()
    iterator insert( const_iterator pos, const T& value ); (1)
    iterator insert( const_iterator pos, T&& value ); (2)
    iterator insert( const_iterator pos, size_type count,
        const T& value ); (3)
    template< class InputIt >
    iterator insert( const_iterator pos, InputIt first, InputIt last ); (4)
    iterator insert( const_iterator pos, std::initializer_list<T> ilist ); (5)

    std::list<int> c1(3, 100);
    auto pos = c1.begin();
    pos = c1.insert(pos, 200); // [200, 100, 100, 100]
    c1.insert(pos, 2, 300); // [300, 300, 200, 100, 100, 100]
    pos = c1.begin();
    std::list<int> c2(2, 400);
    c1.insert(std::next(pos, 2), c2.begin(), c2.end());
    // [300, 300, 400, 400, 200, 100, 100, 100]
    int arr[] = {501, 502, 503};
    c1.insert(c1.begin(), arr, arr + std::size(arr));
    // [501, 502, 503, 300, 300, 400, 400, 200, 100, 100, 100]
    c1.insert(c1.end(), {601, 602, 603});
    // [501, 502, 503, 300, 300, 400, 400, 200, 100, 100, 100, 601, 602, 603]

list::insert_range()
    auto container = std::list{1, 2, 3, 4};
    auto pos = std::next(container.begin(), 2);
    const auto rg = std::vector{-1, -2, -3};
    container.insert_range(pos, rg);

list::erase()
    iterator erase( const_iterator pos );
    iterator erase( const_iterator first, const_iterator last );
    Returns iterator following the last removed element.
    c.erase(range_begin, range_end);
    it = c.erase(it);

list::push_back()
    letters.push_back("abc"); // return none
list::append_range()
    auto head = std::list{1, 2, 3, 4};
    const auto tail = std::vector{-5, -6, -7};
    head.append_range(tail);
list::pop_back()
    numbers.pop_back(); // return none
list::push_front()
    letters.push_front("abc");
    or letters.push_front(std::move(s));
    // return none;
list::prepend_range()
    auto container = std::list{0, 1, 2, 3};
    const auto rg = std::vector{-3, -2, -1};
    container.prepend_range(rg);
list::pop_front()
    chars.pop_front() // return none

list::resize()
    void resize( size_type count );
    void resize( size_type count, const value_type& value );
    (see deque::resize) std::list<int> c = {1, 2, 3};
    c.resize(5);
    c.resize(2);
    c.resize(6, 4);

list::swap()
    a1.swap(a2);
list::merge()
    list1.sort();
    list2.sort();
    list1.merge(list2);
    // result is sorted also, return none
list::splice()
    std::list<int> list1{1, 2, 3, 4, 5};
    std::list<int> list2{10, 20, 30, 40, 50};
    auto it = list1.begin();
    std::advance(it, 2);
    list1.splice(it, list2);
    list2 is empty, list1: 1 2 10 20 30 40 50 3 4 5, 'it' points to 3 after splicing
    list2.splice(list2.begin(), list1, it, list1.end());
    // list1: 1 2 10 20 30 40 50 list2: 3 4 5

list::remove()
    auto count1 = l.remove(1);
    // count1 elements (equal to 1) are removed
list::remove_if()
    auto count2 = l.remove_if([](int n){ return n > 10; });
    // count2 elements are removed
list::reverse()
    list.reverse(); // return none
list::unique()
    size_type unique(); // returns number of elements removed
list::sort()
    list.sort();
    list.sort(std::greater<int>());
    // return none

deque::
    at() -> access specified element with bounds checking
    operator[] -> access specified element
    front() -> access the first element
    back() -> access the last element
    begin
    cbegin
    end
    cend
    rbegin
    crbegin() -> returns a reverse iterator to the beginning
    rend
    crend() -> returns a reverse iterator to the end
    empty() -> checks whether the container is empty
    size() -> returns the number of elements
    max_size() -> returns the maximum possible number of
        elements
    shrink_to_fit() -> (DR*) reduces memory usage by freeing
        unused memory
    clear() -> clears the contents
    insert() -> inserts elements
    insert_range() -> inserts a range of elements
    emplace() -> constructs element in-place
    erase() -> erases elements
    push_back() -> adds an element to the end
    emplace_back() -> constructs an element in-place at the
        end
    append_range() -> adds a range of elements to the end
    pop_back() -> removes the last element
    push_front() -> inserts an element to the beginning
    emplace_front() -> constructs an element in-place at the
        beginning
    prepend_range() -> adds a range of elements to the
        beginning
    pop_front() -> removes the first element
    resize() -> changes the number of elements stored
    swap() -> swaps the contents

deque::deque
    std::deque<int> d = {7, 5, 16, 8};
    d.push_front(13);
    d.push_back(25);
    std::deque<int> c1(3, 100);

deque::insert
    iterator insert( const_iterator pos, const T& value );
    iterator insert( const_iterator pos, T&& value );
    iterator insert( const_iterator pos, size_type count, const T& value );
    template< class InputIt > iterator insert( const_iterator pos, InputIt first, InputIt last );

    auto pos = c1.begin();
    pos = c1.insert(pos, 200);
    c1.insert(pos, 2, 300); // overload (3)
    c1.insert(std::next(pos, 2), c2.begin(), c2.end());
    c1.insert(c1.end(), {601, 602, 603});

deque::insert_range
    auto container = std::deque{1, 2, 3, 4};
    auto pos = std::next(container.begin(), 2);
    const auto rg = std::list{-1, -2, -3};
    container.insert_range(pos, rg);
    container.insert(pos, rg.cbegin(), rg.cend());

deque::erase
    c.erase(c.begin()); c.erase(c.begin() + 2, c.begin() + 5); it = c.erase(it);

deque::append_range
    auto head = std::deque{1, 2, 3, 4};
    const auto tail = std::list{-5, -6, -7};
    head.append_range(tail);
    head.insert(head.end(), tail.cbegin(), tail.cend());
    (see append_range) container.prepend_range(rg);

deque::push_back
    letters.push_back("abc"); // returns nothing
deque::pop_back
    numbers.pop_back(); // returns nothing
deque::push_front
    letters.push_front("abc"); // returns nothing
deque::pop_front
    chars.pop_front(); // returns nothing
deque::swap
    a1.swap(a2);

deque::resize
    std::deque<int> c = {1, 2, 3};
    c.resize(5);
    // After resize up to 5: 1 2 3 0 0
    c.resize(2); // After resize down to 2: 1 2
    c.resize(6, 4);
    // After resize up to 6 (initializer = 4): 1 2 4 4 4 4

stack::
    wrapper around deque (see deque)

    top() -> accesses the top element
    empty() -> checks whether the container adaptor is empty
    size() -> returns the number of elements
    push() -> inserts element at the top
    push_range() -> inserts a range of elements at the top
    emplace() -> constructs element in-place at the top
    pop() -> removes the top element
    swap() -> swaps the contents

queue::
    wrapper around deque (see deque)

    front() -> access the first element
    back() -> access the last element
    empty() -> checks whether the container adaptor is empty
    size() -> returns the number of elements
    push() -> inserts element at the end
    push_range() -> inserts a range of elements at the end
    emplace() -> constructs element in-place at the end
    pop() -> removes the first element
    swap() -> swaps the contents

--- map and set
insert_or_assign(
emplace_hint(
try_emplace(
extract(
merge(
count()
find(
contains(
equal_range(
lower_bound(
upper_bound(
key_comp(
value_comp(

map::
    at() <-> access specified element with bounds checking
    operator[] <-> access or insert specified element
    begin() <-> returns an iterator to the beginning
    cbegin() <-> returns an iterator to the beginning
    end() <-> returns an iterator to the end
    cend() <-> returns an iterator to the end
    rbegin() <-> returns a reverse iterator to the beginning
    crbegin() <-> returns a reverse iterator to the beginning
    rend() <-> returns a reverse iterator to the end
    crend() <-> returns a reverse iterator to the end
    empty() <-> checks whether the container is empty
    size() <-> returns the number of elements
    max_size() <-> returns the maximum possible number of elements
    clear() <-> clears the contents
    insert() <-> inserts elements or nodes(since C++17)
    insert_range() <-> inserts a range of elements
    insert_or_assign() <-> inserts an element or assigns to the current
        element if the key already exists
    emplace() <-> constructs element in-place
    emplace_hint() <-> constructs elements in-place using a hint
    try_emplace() <-> inserts in-place if the key does not exist, does nothing
        if the key exists
    erase() <-> erases elements
    swap() <-> swaps the contents
    extract() <-> extracts nodes from the container
    merge() <-> splices nodes from another container
    count() <-> returns the number of elements matching specific key
    find() <-> finds element with specific key
    contains() <-> checks if the container contains element with specific key
    equal_range() <-> returns range of elements matching a specific key
    lower_bound() <-> returns an iterator to the first element not less than
        the given key
    upper_bound() <-> returns an iterator to the first element greater than
        the given key
    key_comp() <-> returns the function that compares keys
    value_comp() <-> returns the function that compares keys in objects of
        type value_type

map::map
    map<int, int> f {{1,2},{3,4}};
    auto f = map{pair{1, 11}, {3, 33}, {2, 22}, {4, 44}};
    map iterate:
        for (const auto& [key, value] : m)
           std::cout << '[' << key << "] = " << value << "; ";

map::insert
    mapx.insert(pair(1,2))
    mapx.insert({1,2})
    const auto rg = {std::pair{-1, -11}, {3, -33}, {-2, -22}};
    mapx.insert(rg.begin(), rg.end());
    const auto rg = {std::pair{-1, -11}, {3, -33}, {-2, -22}}; (-> vector)
    mapx.insert(rg);

map::emplace
    mapx.emplace("d", "ddd"); -> map<std::string, std::string> mapx;
    mapx.emplace(std::make_pair("b", "abcd"));

map::erase()
    it = mapx.erase(it);
    Removes the element at pos, or in the range [first, last), or with the key==a_key
    Returns iterator following the last removed element, or Number of elements removed.
    std::erase_if(m, [](const auto& pair){ return pair.second > 25; });

map::swap
    mapx.swap(mapy);

map::count
    size_type map::count( const Key& key )

map::find
    if(auto search = map_foo.find(2); map_foo != example.end())
        std::cout << "Found " << map_foo->first << ' ' << map_foo->second << '\n';

map::contains
    if (mapx.contains(x))

map::equal_range
    auto p = m.equal_range(key);
    for (auto& q = p.first; q != p.second; ++q)
        cout<<q->first<<q->second;
    auto p = m.lower_bound(key);
    auto p = m.upper_bound(key);

set::
    begin()
    cbegin()
    end()
    cend()
    rbegin()
    crbegin()
    rend() <-> returns a reverse iterator to the end
    crend() <-> returns a reverse iterator to the end
    empty() <-> checks whether the container is empty
    size() <-> returns the number of elements
    max_size() <-> returns the maximum possible number of elements
    clear() <-> clears the contents
    insert() <-> inserts elements or nodes(since C++17)
    insert_range() <-> inserts a range of elements
    emplace() <-> constructs element in-place
    emplace_hint() <-> constructs elements in-place using a hint
    erase() <-> erases elements
    swap() <-> swaps the contents
    extract() <-> extracts nodes from the container
    merge() <-> splices nodes from another container
    count() <-> returns the number of elements matching specific key
    find() <-> finds element with specific key
    contains() <-> checks if the container contains element with specific key
    equal_range() <-> returns range of elements matching a specific key
    lower_bound() <-> returns an iterator to the first element not less than the given key
    upper_bound() <-> returns an iterator to the first element greater than the given key
    key_comp() <-> returns the function that compares keys
    value_comp() <-> returns the function that compares keys in objects of type value_type

set::set
    set<int> set{1, 5, 3};  // can name a set as 'set'
set::empty
    if (set.empty())
set::erase
    set.erase(1);
set::contains
    if (set.contains(key))

set->print
    for_each(set.begin(), set.end(), [&out](const T& element) out << ", " << element;

set::clear()
    setx.clear();

set::insert()
    set.insert(v.begin(), v.end());

    auto result_1 = set.insert(3);
    assert(result_1.first != set.end()); // it is a valid iterator

    auto result_1 = set.insert(3);
    assert(*result_1.first == 3);
    if (!result_2.second)
       std::cout << "no insertion\n";

set::insert_range()
    const auto rg = {-1, 3, -2};
    setx.insert_range(rg);  // in C++20
    setx.insert(rg.begin(), rg.end());

set::erase()
    it = c.erase(it); // see map::erase, can use iterators

set::swap()
    a1.swap(a2); E
    very iterator referring to an element in one container before the swap
    refers to the same element in the other container after the swap.

set::find()
    if (auto search = example.find(2);
        search != example.end())
set::contains()
    if (example.contains(x))
set::equal_range()
    auto [begin, end] = characters.equal_range(names); (see map::equal_range)
set::lower_bound()
    no example
set::upper_bound()
    no example

--- string
assign(
assign_range(
c_str(
length(
append(
replace_with_range(
resize_and_overwrite(
find(
rfind(
find_first_of(
find_first_not_of(
find_last_of(
find_last_not_of(
compare(
starts_with(
ends_with(
substr(start, length)

string::
    mutable (unlike java string, and C's char *f="foo"

    operator= -> assigns values to the string
    assign() -> assign characters to a string
    assign_range() -> assign a range of characters to a string
    get_allocator() -> returns the associated allocator
    at() -> accesses the specified character with bounds checking
    operator[]() -> accesses the specified character
    front() -> accesses the first character
    back() -> accesses the last character
    data() -> returns a pointer to the first character of a string
    c_str() -> returns a non-modifiable standard C character array version of the string
    operator() -> basic_string_view returns a non-modifiable basic_string_view into the entire string
    begin()
    cbegin()
    end()
    cend()
    rbegin()
    crbegin() -> returns a reverse iterator to the beginning
    rend()
    crend() -> returns a reverse iterator to the end
    empty() -> checks whether the string is empty
    size() -> returns the number of characters
    length() -> returns the number of characters
    max_size() -> returns the maximum number of characters
    reserve() -> reserves storage
    capacity() -> returns the number of characters that can be held in currently allocated storage
    shrink_to_fit() -> reduces memory usage by freeing unused memory
    clear() -> clears the contents
    insert() -> inserts characters
    insert_range() -> inserts a range of characters
    erase() -> removes characters
    push_back() -> appends a character to the end
    pop_back() -> removes the last character
    append() -> appends characters to the end
    append_range() -> appends a range of characters to the end
    operator+=() -> appends characters to the end
    replace() -> replaces specified portion of a string
    replace_with_range() -> replaces specified portion of a string with a range of characters
    copy() -> copies characters
    resize() -> changes the number of characters stored
    resize_and_overwrite() -> changes the number of characters stored and possibly overwrites indeterminate contents via user-provided operation
    swap() -> swaps the contents
    find() -> finds the first occurrence of the given substring
    rfind() -> find the last occurrence of a substring
    find_first_of() -> find first occurrence of characters
    find_first_not_of() -> find first absence of characters
    find_last_of() -> find last occurrence of characters
    find_last_not_of() -> find last absence of characters
    compare() -> compares two strings
    starts_with() -> checks if the string starts with the given prefix
    ends_with() -> checks if the string ends with the given suffix
    contains() -> checks if the string contains the given substring or character
    substr() -> returns a substring

string::(non-member fn)
    operator+ concatenates two strings, a string and a char, or a string and string_view
    operator==
    operator!=
    operator<
    operator>
    operator<=
    operator>=
    operator<=>
        lexicographically compares two strings
    std::swap(std::basic_string) specializes the std::swap algorithm
    std::erase(std::basic_string) erases all elements satisfying specific criteria
    std::erase_if(std::basic_string) erases all elements satisfying specific criteria
    operator<< and operator>> -> performs stream input and output on strings
    getline() -> read data from an I/O stream into a string
    stoi() stol() stoll() -> converts a string to a signed integer
    stoul() stoull() -> converts a string to an unsigned integer
    stof() stod() stold() -> converts a string to a floating point value
    to_string() -> converts an integral or floating-point value to string
    to_wstring() -> converts an integral or floating-point value to wstring

string::()
    std::string	std::basic_string<char>
    std::wstring	std::basic_string<wchar_t> // wide string
    std::u8string   std::basic_string<char8_t>
    std::u16string  std::basic_string<char16_t>
    std::u32string  std::basic_string<char32_t>

string::assign
    s.assign(4, '='); // "====";
    s.assign(c); // assign(const basic_string& str)
    s.assign(c, 0, c.length() - 1);
       // assign(const basic_string& str, size_type pos, size_type count)
    s.assign(std::string("C++ by ") + "example");
       // assign(basic_string&& str)
    s.assign("C-style string", 7); // assign(const CharT* s, size_type count)
    s.assign("C-style\0string"); // assign(const CharT* s)
    char mutable_c_str[] = "C-style string";
    s.assign(std::begin(mutable_c_str), std::end(mutable_c_str) - 1);
       // assign(InputIt first, InputIt last)
    s.assign({'C', '-', 's', 't', 'y', 'l', 'e'});
       // assign(std::initializer_list<CharT> ilist)

string::assign_range()
    destination.assign_range(source); // same as destination.assign(source.begin(), source.end());

string::insert()
    s.insert(0, 1, 'E'); // insert(size_type index, size_type count, char ch)
    s.insert(2, "e"); // insert(size_type index, const char* s)
    s.insert(6, "a"s); // insert(size_type index, string const& str)
    s.insert(8, " is an example string."s, 0, 14);
     // insert(size_type index, string const& str, size_type s_index, size_type count)
    s.insert(s.cbegin() + s.find_first_of('n') + 1, ':');
     // insert(const_iterator pos, char ch)
    s.insert(s.cbegin() + s.find_first_of(':') + 1, 2, '=');
     // insert(const_iterator pos, size_type count, char ch)
    s.insert(s.begin() + s.find_last_of('e') + 1, std::begin(seq), std::end(seq));
     // insert(const_iterator pos, InputIt first, InputIt last)
    s.insert(s.cbegin() + s.find_first_of('g') + 1, {'.'});
     // insert(const_iterator pos, std::initializer_list<char>)

string::insert_range()
    target.insert_range(iter, source); // same as target.insert(iter, source.begin(), source.end());

string::erase()
    std::string s = "This Is An Example"; s.erase(7, 3); // erases " An"
    s.erase(std::find(s.begin(), s.end(), ' ')); // erases first ' ';
    s.erase(s.find(' ')); // trims from ' ' to the end of the string;
    auto it = std::next(s.begin(), s.find('s')); // obtains iterator to the first 's'
    s.erase(it, std::next(it, 2)); // erases "sI";

string::push_back()
    str.push_back('!');
string::pop_back()
    str.pop_back();

string::append
    std::basic_string<char> str = "string";
    const char* cptr = "C-string";
    const char carr[] = "Two and one";
    std::string output;
    output.append(3, '*'); // 1) Append a char 3 times.
    output.append(str); // 2) Append a whole string
    output.append(str, 3, 3); // 3) Append part of a string (last 3 letters, in this case)
    output.append(1, ' ').append(carr, 4);
     // 4) Append part of a C-string. `append` returns *this, we can chain calls together
    output.append(cptr); // 5) Append a whole C-string
    output.append(&carr[3], std::end(carr)); // 6) Append range
    output.append({' ', 'l', 'i', 's', 't'}); // 7) Append initializer list


string::append_range()


string::operator+=()


string::replace()


string::replace_with_range()


string::copy()


string::resize()


string::resize_and_overwrite()


string::swap()


string::find()


string::rfind()


string::find_first_of()


string::find_first_not_of()


string::find_last_of()


string::find_last_not_of()


string::compare()


string::starts_with()
    constexpr bool
        starts_with( std::basic_string_view<CharT,Traits> sv ) const noexcept;
    (1)	(since C++20)
    constexpr bool
        starts_with( CharT ch ) const noexcept;
    (2)	(since C++20)
    constexpr bool
        starts_with( const CharT* s ) const;
    (3)	(since C++20)
    Checks if the string begins with the given prefix. The prefix may be one
    of the following:

    1) A string view sv (which may be a result of implicit conversion from
    another std::basic_string).
    2) A single character ch.
    3) A null-terminated character string s.
    All three overloads effectively return std::basic_string_view<CharT,
    Traits>(data(), size()).starts_with(x), where x is the parameter.

    Parameters
    sv	-	a string view which may be a result of implicit conversion from
    another std::basic_string
    ch	-	a single character
    s	-	a null-terminated character string
    Return value
    true if the string begins with the provided prefix, false otherwise.

    Example

    int main()
    {
        using namespace std::literals;

        const auto str = "Hello, C++20!"s;

        assert
        (""
            && str.starts_with("He"sv)  // (1)
            && !str.starts_with("he"sv) // (1)
            && str.starts_with("He"s)   // (1) implicit conversion string to
    string_view
            && !str.starts_with("he"s)  // (1) implicit conversion string to
    string_view
            && str.starts_with('H')     // (2)
            && !str.starts_with('h')    // (2)
            && str.starts_with("He")    // (3)
            && !str.starts_with("he")   // (3)
        );
    }

    string::ends_with()
    constexpr bool
        ends_with( std::basic_string_view<CharT, Traits> sv ) const noexcept;
    (1)	(since C++20)
    constexpr bool
        ends_with( CharT ch ) const noexcept;
    (2)	(since C++20)
    constexpr bool
        ends_with( const CharT* s ) const;
    (3)	(since C++20)
    Checks if the string ends with the given suffix. The suffix may be one of
    the following:

    1) A string view sv (which may be a result of implicit conversion from
    another std::basic_string).
    2) A single character ch.
    3) A null-terminated character string s.
    All three overloads effectively return std::basic_string_view<CharT,
    Traits>(data(), size()).ends_with(x), where x is the parameter.

    Parameters
    sv	-	a string view which may be a result of implicit conversion from
    another std::basic_string
    ch	-	a single character
    s	-	a null-terminated character string
    Return value
    true if the string ends with the provided suffix, false otherwise.

    Example

    int main()
    {
        using namespace std::literals;

        const auto str = "Hello, C++20!"s;

        assert
        (""
            && str.ends_with("C++20!"sv)  // (1)
            && !str.ends_with("c++20!"sv) // (1)
            && str.ends_with("C++20!"s)   // (1) implicit conversion string to string_view
            && !str.ends_with("c++20!"s)  // (1) implicit conversion string to string_view
            && str.ends_with('!')         // (2)
            && !str.ends_with('?')        // (2)
            && str.ends_with("C++20!")    // (3)
            && !str.ends_with("c++20!")   // (3)
        );
    }

string::contains()
    constexpr bool
        contains( std::basic_string_view<CharT,Traits> sv ) const noexcept;
    (1)	(since C++23)
    constexpr bool
        contains( CharT ch ) const noexcept;
    (2)	(since C++23)
    constexpr bool
        contains( const CharT* s ) const;
    (3)	(since C++23)
    Checks if the string contains the given substring. The substring may be
    one of the following:

    1) A string view sv (which may be a result of implicit conversion from
    another std::basic_string).
    2) A single character ch.
    3) A null-terminated character string s.
    All three overloads are equivalent to return find(x) != npos;, where x is
    the parameter.

    Parameters
    sv	-	a string view which may be a result of implicit conversion from
    another std::basic_string
    ch	-	a single character
    s	-	a null-terminated character string
    Return value
    true if the string contains the provided substring, false otherwise.

    Example

    template<typename SubstrType>
    void test_substring(const std::string& str, SubstrType subs)
    {
        constexpr char delim = std::is_scalar_v<SubstrType> ? '\'' : '\"';
        std::cout << std::quoted(str)
                  << (str.contains(subs) ? " contains "
                                         : " does not contain ")
                  << std::quoted(std::string{subs}, delim) << '\n';
    }

    int main()
    {
        using namespace std::literals;

        auto helloWorld = "hello world"s;

        test_substring(helloWorld, "hello"sv);
        test_substring(helloWorld, "goodbye"sv);
        test_substring(helloWorld, 'w');
        test_substring(helloWorld, 'x');
    }
    Output:

    "hello world" contains "hello"
    "hello world" does not contain "goodbye"
    "hello world" contains 'w'
    "hello world" does not contain 'x'

string::substr()
    basic_string substr( size_type pos = 0, size_type count = npos ) const;
    constexpr basic_string
        substr( size_type pos = 0, size_type count = npos ) const&;
    constexpr basic_string substr( size_type pos = 0, size_type count = npos )
        &&;
    Returns a substring [pos, pos + count). If the requested substring extends
    past the end of the string, i.e. the count is greater than size() - pos (e.g.
    if count == npos), the returned substring is [pos, size()).

    Parameters
    pos	-	position of the first character to include
    count	-	length of the substring

    Return value
    String containing the substring [pos, pos + count) or [pos, size()).

    int main()
    {
        std::string a = "0123456789abcdefghij";

        // count is npos, returns [pos, size())
        std::string sub1 = a.substr(10);
        std::cout << sub1 << '\n';

        // both pos and pos + count are within bounds, returns [pos, pos + count)
        std::string sub2 = a.substr(5, 3);
        std::cout << sub2 << '\n';

        // pos is within bounds, pos + count is not, returns [pos, size())
        std::string sub4 = a.substr(a.size() - 3, 50);
        // this is effectively equivalent to
        // std::string sub4 = a.substr(17, 3);
        // since a.size() == 20, pos == a.size() - 3 == 17, and a.size() - pos == 3

        std::cout << sub4 << '\n';

        try
        {
            // pos is out of bounds, throws
            std::string sub5 = a.substr(a.size() + 3, 50);
            std::cout << sub5 << '\n';
        }
        catch (const std::out_of_range& ex)
        {
            std::cout << ex.what() << '\n';
        }
    }
    Possible output:

    abcdefghij
    567
    hij
    basic_string::substr: __pos (which is 23) > this->size() (which is 20)

string:: std::erase
string:: std::erase_if
    template< class CharT, class Traits, class Alloc, class U >
    constexpr std::basic_string<CharT, Traits, Alloc>::size_type
        erase( std::basic_string<CharT, Traits, Alloc>& c, const U& value );
    (since C++20)
    (until C++26)
    template< class CharT, class Traits, class Alloc, class U = CharT >
    constexpr std::basic_string<CharT, Traits, Alloc>::size_type
        erase( std::basic_string<CharT, Traits, Alloc>& c, const U& value );
    (since C++26)
    template< class CharT, class Traits, class Alloc, class Pred >
    constexpr std::basic_string<CharT, Traits, Alloc>::size_type
        erase_if( std::basic_string<CharT, Traits, Alloc>& c, Pred pred );

    c	-	container from which to erase
    value	-	value to be removed
    pred	-	unary predicate which returns true if the element should be
    erased.

    int main()
    {
        std::string word{"startling"};
        std::cout << "Initially, word = " << std::quoted(word) << '\n';

        std::erase(word, 'l');
        std::cout << "After erase 'l': " << std::quoted(word) << '\n';

        auto erased = std::erase_if(word, [](char x)
        {
            return x == 'a' or x == 'r' or x == 't';
        });

        std::cout << "After erase all 'a', 'r', and 't': " <<
            std::quoted(word) << '\n';
        std::cout << "Erased symbols count: " << erased << '\n';

    #if __cpp_lib_algorithm_default_value_type
        std::erase(word, {'g'});
        std::cout << "After erase {'g'}: " << std::quoted(word) << '\n';
    #endif
    }
    Possible output:

    Initially, word = "startling"
    After erase 'l', word = "starting"
    After erase all 'a', 'r', and 't': "sing"
    Erased symbols count: 4
    After erase {'g'}: "sin"gs

string:: std::getline
    int main()
    {
        // greet the user
        std::string name;
        std::cout << "What is your name? ";
        std::getline(std::cin, name);
        std::cout << "Hello " << name << ", nice to meet you.\n";

        // read file line by line
        std::istringstream input;
        input.str("1\n2\n3\n4\n5\n6\n7\n");
        int sum = 0;
        for (std::string line; std::getline(input, line);)
            sum += std::stoi(line);
        std::cout << "\nThe sum is " << sum << ".\n\n";

        // use separator to read parts of the line
        std::istringstream input2;
        input2.str("a;b;c;d");
        for (std::string line; std::getline(input2, line, ';');)
            std::cout << line << '\n';
    }
    Possible output:

    What is your name? John Q. Public
    Hello John Q. Public, nice to meet you.

    The sum is 28.

    a
    b
    c
    d

string:: operator<<,>>
        int main()
        {
            std::string greeting = "Hello, whirled!";
            std::istringstream iss(greeting);
            std::string hello_comma, whirled, word;
            iss >> hello_comma;
            iss >> whirled;
            std::cout << greeting << '\n'
                      << hello_comma << '\n' << whirled << '\n';
            // Reset the stream
            iss.clear();
            iss.seekg(0);
            while (iss >> word)
                std::cout << '+' << word << '\n';
        }
        Output:
        Hello, whirled!
        Hello,
        whirled!
        +Hello,
        +whirled!


--- standard library headers

<cctype>
    Functions
    isalnum -> checks if a character is alphanumeric
    isalpha -> checks if a character is alphabetic
    islower -> checks if a character is lowercase
    isupper -> checks if a character is an uppercase character
    isdigit -> checks if a character is a digit
    isxdigit -> checks if a character is a hexadecimal character
    iscntrl -> checks if a character is a control character
    isgraph -> checks if a character is a graphical character
    isspace -> checks if a character is a space character
    isblank -> checks if a character is a blank character
    isprint -> checks if a character is a printing character
    ispunct -> checks if a character is a punctuation character
    tolower -> converts a character to lowercase
    toupper -> converts a character to uppercase

    Synopsis

    namespace std {
      int isalnum(int c);
      int isalpha(int c);
      int isblank(int c);
      int iscntrl(int c);
      int isdigit(int c);
      int isgraph(int c);
      int islower(int c);
      int isprint(int c);
      int ispunct(int c);
      int isspace(int c);
      int isupper(int c);
      int isxdigit(int c);
      int tolower(int c);
      int toupper(int c);
    }

--- Algorithms

..alg_batch
    for_each
        applies a function to a range of elements
    ranges::for_each
        applies a function to a range of elements
    for_each_n
        applies a function object to the first N elements of a sequence
    ranges::for_each_n
        applies a function object to the first N elements of a sequence

for_each
    applies a function to a range of elements
ranges::for_each
    applies a function to a range of elements
for_each_n
    applies a function object to the first N elements of a sequence
ranges::for_each_n
    applies a function object to the first N elements of a sequence

..alg_search
    all_of
        checks if a predicate is true for all, any or none of the elements in a range
    any_of
        checks if a predicate is true for all, any or none of the elements in a range
    none_of
        checks if a predicate is true for all, any or none of the elements in a range
    ranges::all_of
        checks if a predicate is true for all, any or none of the elements in a range
    ranges::any_of
        checks if a predicate is true for all, any or none of the elements in a range
    ranges::none_of
        checks if a predicate is true for all, any or none of the elements in a range
    ranges::contains
        checks if the range contains the given element or subrange
    ranges::contains_subrange
        checks if the range contains the given element or subrange
    find
        finds the first element satisfying specific criteria
    find_if
        finds the first element satisfying specific criteria
    find_if_not
        finds the first element satisfying specific criteria
    ranges::find
        finds the first element satisfying specific criteria
    ranges::find_if
        finds the first element satisfying specific criteria
    ranges::find_if_not
        finds the first element satisfying specific criteria
    ranges::find_last
        finds the last element satisfying specific criteria
    ranges::find_last_if
        finds the last element satisfying specific criteria
    ranges::find_last_if_not
        finds the last element satisfying specific criteria
    find_end
        finds the last sequence of elements in a certain range
    ranges::find_end
        finds the last sequence of elements in a certain range
    find_first_of
        searches for any one of a set of elements
    ranges::find_first_of
        searches for any one of a set of elements
    adjacent_find
        finds the first two adjacent items that are equal (or satisfy a given predicate)
    ranges::adjacent_find
        finds the first two adjacent items that are equal (or satisfy a given predicate)
    count
        returns the number of elements satisfying specific criteria
    count_if
        returns the number of elements satisfying specific criteria
    ranges::count
        returns the number of elements satisfying specific criteria
    ranges::count_if
        returns the number of elements satisfying specific criteria
    mismatch
        finds the first position where two ranges differ
    ranges::mismatch
        finds the first position where two ranges differ
    equal
        determines if two sets of elements are the same
    ranges::equal
        determines if two sets of elements are the same
    search
        searches for the first occurrence of a range of elements
    ranges::search
        searches for the first occurrence of a range of elements
    search_n
        searches for the first occurrence of a number consecutive copies of an element in a range
    ranges::search_n
        searches for the first occurrence of a number consecutive copies of an element in a range
    ranges::starts_with
        checks whether a range starts with another range
    ranges::ends_with
        checks whether a range ends with another range

all_of
    checks if a predicate is true for all, any or none of the elements in a range
any_of
    checks if a predicate is true for all, any or none of the elements in a range
none_of
    checks if a predicate is true for all, any or none of the elements in a range
ranges::all_of
    checks if a predicate is true for all, any or none of the elements in a range
ranges::any_of
    checks if a predicate is true for all, any or none of the elements in a range
ranges::none_of
    checks if a predicate is true for all, any or none of the elements in a range
ranges::contains
    checks if the range contains the given element or subrange
ranges::contains_subrange
    checks if the range contains the given element or subrange
find
    finds the first element satisfying specific criteria
find_if
    finds the first element satisfying specific criteria
find_if_not
    finds the first element satisfying specific criteria
ranges::find
    finds the first element satisfying specific criteria
ranges::find_if
    finds the first element satisfying specific criteria
ranges::find_if_not
    finds the first element satisfying specific criteria
ranges::find_last
    finds the last element satisfying specific criteria
ranges::find_last_if
    finds the last element satisfying specific criteria
ranges::find_last_if_not
    finds the last element satisfying specific criteria
find_end
    finds the last sequence of elements in a certain range
ranges::find_end
    finds the last sequence of elements in a certain range
find_first_of
    searches for any one of a set of elements
ranges::find_first_of
    searches for any one of a set of elements
adjacent_find
    finds the first two adjacent items that are equal (or satisfy a given predicate)
ranges::adjacent_find
    finds the first two adjacent items that are equal (or satisfy a given predicate)
count
    returns the number of elements satisfying specific criteria
count_if
    returns the number of elements satisfying specific criteria
ranges::count
    returns the number of elements satisfying specific criteria
ranges::count_if
    returns the number of elements satisfying specific criteria
mismatch
    finds the first position where two ranges differ
ranges::mismatch
    finds the first position where two ranges differ
equal
    determines if two sets of elements are the same
ranges::equal
    determines if two sets of elements are the same
search
    searches for the first occurrence of a range of elements
ranges::search
    searches for the first occurrence of a range of elements
search_n
    searches for the first occurrence of a number consecutive copies of an element in a range
ranges::search_n
    searches for the first occurrence of a number consecutive copies of an element in a range
ranges::starts_with
    checks whether a range starts with another range
ranges::ends_with
    checks whether a range ends with another range

..alg_fold
    ranges::fold_left
        left-folds a range of elements
    ranges::fold_left_first
        left-folds a range of elements using the first element as an initial value
    ranges::fold_right
        right-folds a range of elements
    ranges::fold_right_last
        right-folds a range of elements using the last element as an initial value
    ranges::fold_left_with_iter
        left-folds a range of elements, and returns a pair (iterator, value)
    ranges::fold_left_first_with_iter
        left-folds a range of elements using the first element as an initial value, and returns a pair (iterator, optional)

ranges::fold_left
    left-folds a range of elements
ranges::fold_left_first
    left-folds a range of elements using the first element as an initial value
ranges::fold_right
    right-folds a range of elements
ranges::fold_right_last
    right-folds a range of elements using the last element as an initial value
ranges::fold_left_with_iter
    left-folds a range of elements, and returns a pair (iterator, value)
ranges::fold_left_first_with_iter
    left-folds a range of elements using the first element as an initial value, and returns a pair (iterator, optional)

..alg_copy
    copy
        copies a range of elements to a new location
    copy_if
        copies a range of elements to a new location
    ranges::copy
        copies a range of elements to a new location
    ranges::copy_if
        copies a range of elements to a new location
    copy_n
        copies a number of elements to a new location
    ranges::copy_n
        copies a number of elements to a new location
    copy_backward
        copies a range of elements in backwards order
    ranges::copy_backward
        copies a range of elements in backwards order

copy
    copies a range of elements to a new location
copy_if
    copies a range of elements to a new location
ranges::copy
    copies a range of elements to a new location
ranges::copy_if
    copies a range of elements to a new location
copy_n
    copies a number of elements to a new location
ranges::copy_n
    copies a number of elements to a new location
copy_backward
    copies a range of elements in backwards order
ranges::copy_backward
    copies a range of elements in backwards order

..alg_move
    move
        moves a range of elements to a new location
    ranges::move
        moves a range of elements to a new location
    move_backward
        moves a range of elements to a new location in backwards order
    ranges::move_backward
        moves a range of elements to a new location in backwards order

move
    moves a range of elements to a new location
ranges::move
    moves a range of elements to a new location
move_backward
    moves a range of elements to a new location in backwards order
ranges::move_backward
    moves a range of elements to a new location in backwards order

..alg_swap
    swap
        swaps the values of two objects
    swap_ranges
        swaps two ranges of elements
    ranges::swap_ranges
        swaps two ranges of elements
    iter_swap
        swaps the elements pointed to by two iterators

swap
    swaps the values of two objects
swap_ranges
    swaps two ranges of elements
ranges::swap_ranges
    swaps two ranges of elements
iter_swap
    swaps the elements pointed to by two iterators

..alg_transform
    transform
        applies a function to a range of elements, storing results in a destination range
    ranges::transform
        applies a function to a range of elements

transform
    applies a function to a range of elements, storing results in a destination range
ranges::transform
    applies a function to a range of elements

..alg_replace
    replace
        replaces all values satisfying specific criteria with another value
    replace_if
        replaces all values satisfying specific criteria with another value
    ranges::replace
        replaces all values satisfying specific criteria with another value
    ranges::replace_if
        replaces all values satisfying specific criteria with another value
    replace_copy
        copies a range, replacing elements satisfying specific criteria with another value
    replace_copy_if
        copies a range, replacing elements satisfying specific criteria with another value
    ranges::replace_copy
        copies a range, replacing elements satisfying specific criteria with another value
    ranges::replace_copy_if
        copies a range, replacing elements satisfying specific criteria with another value

dreplace
    replaces all values satisfying specific criteria with another value
dreplace_if
    replaces all values satisfying specific criteria with another value
dranges::replace
    replaces all values satisfying specific criteria with another value
dranges::replace_if
    replaces all values satisfying specific criteria with another value
dreplace_copy
    copies a range, replacing elements satisfying specific criteria with another value
dreplace_copy_if
    copies a range, replacing elements satisfying specific criteria with another value
dranges::replace_copy
    copies a range, replacing elements satisfying specific criteria with another value
dranges::replace_copy_if
    copies a range, replacing elements satisfying specific criteria with another value

..alg_generate
    fill
        copy-assigns the given value to every element in a range
    ranges::fill
        assigns a range of elements a certain value
    fill_n
        copy-assigns the given value to N elements in a range
    ranges::fill_n
        assigns a value to a number of elements
    generate
        assigns the results of successive function calls to every element in a range
    ranges::generate
        saves the result of a function in a range
    generate_n
        assigns the results of successive function calls to N elements in a range
    ranges::generate_n
        saves the result of N applications of a function

fill
    copy-assigns the given value to every element in a range
ranges::fill
    assigns a range of elements a certain value
fill_n
    copy-assigns the given value to N elements in a range
ranges::fill_n
    assigns a value to a number of elements
generate
    assigns the results of successive function calls to every element in a range
ranges::generate
    saves the result of a function in a range
generate_n
    assigns the results of successive function calls to N elements in a range
ranges::generate_n
    saves the result of N applications of a function

..alg_remove
    remove
        removes elements satisfying specific criteria
    remove_if
        removes elements satisfying specific criteria
    ranges::remove
        removes elements satisfying specific criteria
    ranges::remove_if
        removes elements satisfying specific criteria
    remove_copy
        copies a range of elements omitting those that satisfy specific criteria
    remove_copy_if
        copies a range of elements omitting those that satisfy specific criteria
    ranges::remove_copy
        copies a range of elements omitting those that satisfy specific criteria
    ranges::remove_copy_if
        copies a range of elements omitting those that satisfy specific criteria
    unique
        removes consecutive duplicate elements in a range
    ranges::unique
        removes consecutive duplicate elements in a range
    unique_copy
        creates a copy of some range of elements that contains no consecutive duplicates
    ranges::unique_copy
        creates a copy of some range of elements that contains no consecutive duplicates

remove
    removes elements satisfying specific criteria
remove_if
    removes elements satisfying specific criteria
ranges::remove
    removes elements satisfying specific criteria
ranges::remove_if
    removes elements satisfying specific criteria
remove_copy
    copies a range of elements omitting those that satisfy specific criteria
remove_copy_if
    copies a range of elements omitting those that satisfy specific criteria
ranges::remove_copy
    copies a range of elements omitting those that satisfy specific criteria
ranges::remove_copy_if
    copies a range of elements omitting those that satisfy specific criteria
unique
    removes consecutive duplicate elements in a range
ranges::unique
    removes consecutive duplicate elements in a range
unique_copy
    creates a copy of some range of elements that contains no consecutive duplicates
ranges::unique_copy
    creates a copy of some range of elements that contains no consecutive duplicates

..alg_reverse
    reverse
        reverses the order of elements in a range
    ranges::reverse
        reverses the order of elements in a range
    reverse_copy
        creates a copy of a range that is reversed
    ranges::reverse_copy
        creates a copy of a range that is reversed

reverse
    reverses the order of elements in a range
ranges::reverse
    reverses the order of elements in a range
reverse_copy
    creates a copy of a range that is reversed
ranges::reverse_copy
    creates a copy of a range that is reversed

..alg_rotate_shift_shuffle

    rotate
        rotates the order of elements in a range
    ranges::rotate
        rotates the order of elements in a range
    rotate_copy
        copies and rotate a range of elements
    ranges::rotate_copy
        copies and rotate a range of elements
    shift_left
        shifts elements in a range
    shift_right
        shifts elements in a range
    shuffle
        randomly re-orders elements in a range
    ranges::shuffle
        randomly re-orders elements in a range
    ranges::shift_left
        shifts elements in a range
    ranges::shift_right
        shifts elements in a range

rotate
    rotates the order of elements in a range
ranges::rotate
    rotates the order of elements in a range
rotate_copy
    copies and rotate a range of elements
ranges::rotate_copy
    copies and rotate a range of elements
shift_left
    shifts elements in a range
shift_right
    shifts elements in a range
shuffle
    randomly re-orders elements in a range
ranges::shuffle
    randomly re-orders elements in a range
ranges::shift_left
    shifts elements in a range
ranges::shift_right
    shifts elements in a range

..alg_sample
    sample
        selects N random elements from a sequence
    ranges::sample
        selects N random elements from a sequence

sample
    selects N random elements from a sequence
ranges::sample
    selects N random elements from a sequence

..alg_partition
    is_partitioned
        determines if the range is partitioned by the given predicate
    ranges::is_partitioned
        determines if the range is partitioned by the given predicate
    partition
        divides a range of elements into two groups
    ranges::partition
        divides a range of elements into two groups
    partition_copy
        copies a range dividing the elements into two groups
    ranges::partition_copy
        copies a range dividing the elements into two groups
    stable_partition
        divides elements into two groups while preserving their relative order
    ranges::stable_partition
        divides elements into two groups while preserving their relative order
    partition_point
        locates the partition point of a partitioned range
    ranges::partition_point
        locates the partition point of a partitioned range

is_partitioned
    determines if the range is partitioned by the given predicate
ranges::is_partitioned
    determines if the range is partitioned by the given predicate
partition
    divides a range of elements into two groups
ranges::partition
    divides a range of elements into two groups
partition_copy
    copies a range dividing the elements into two groups
ranges::partition_copy
    copies a range dividing the elements into two groups
stable_partition
    divides elements into two groups while preserving their relative order
ranges::stable_partition
    divides elements into two groups while preserving their relative order
partition_point
    locates the partition point of a partitioned range
ranges::partition_point
    locates the partition point of a partitioned range

..alg_sort
    sort
        sorts a range into ascending order
    ranges::sort
        sorts a range into ascending order
    stable_sort
        sorts a range of elements while preserving order between equal elements
    ranges::stable_sort
        sorts a range of elements while preserving order between equal elements
    partial_sort
        sorts the first N elements of a range
    ranges::partial_sort
        sorts the first N elements of a range
    partial_sort_copy
        copies and partially sorts a range of elements
    ranges::partial_sort_copy
        copies and partially sorts a range of elements
    is_sorted
        checks whether a range is sorted into ascending order
    ranges::is_sorted
        checks whether a range is sorted into ascending order
    is_sorted_until
        finds the largest sorted subrange
    ranges::is_sorted_until
        finds the largest sorted subrange
    nth_element
        partially sorts the given range making sure that it is partitioned by the given element
    ranges::nth_element
        partially sorts the given range making sure that it is partitioned by the given element

sort
    sorts a range into ascending order
ranges::sort
    sorts a range into ascending order
stable_sort
    sorts a range of elements while preserving order between equal elements
ranges::stable_sort
    sorts a range of elements while preserving order between equal elements
partial_sort
    sorts the first N elements of a range
ranges::partial_sort
    sorts the first N elements of a range
partial_sort_copy
    copies and partially sorts a range of elements
ranges::partial_sort_copy
    copies and partially sorts a range of elements
is_sorted
    checks whether a range is sorted into ascending order
ranges::is_sorted
    checks whether a range is sorted into ascending order
is_sorted_until
    finds the largest sorted subrange
ranges::is_sorted_until
    finds the largest sorted subrange
nth_element
    partially sorts the given range making sure that it is partitioned by the given element
ranges::nth_element
    partially sorts the given range making sure that it is partitioned by the given element

..alg_binsearch
    lower_bound
        returns an iterator to the first element not less than the given value
    ranges::lower_bound
        returns an iterator to the first element not less than the given value
    upper_bound
        returns an iterator to the first element greater than a certain value
    ranges::upper_bound
        returns an iterator to the first element greater than a certain value
    equal_range
        returns range of elements matching a specific key
    ranges::equal_range
        returns range of elements matching a specific key
    binary_search
        determines if an element exists in a partially-ordered range
    ranges::binary_search
        determines if an element exists in a partially-ordered range

lower_bound
    returns an iterator to the first element not less than the given value
ranges::lower_bound
    returns an iterator to the first element not less than the given value
upper_bound
    returns an iterator to the first element greater than a certain value
ranges::upper_bound
    returns an iterator to the first element greater than a certain value
equal_range
    returns range of elements matching a specific key
ranges::equal_range
    returns range of elements matching a specific key
binary_search
    determines if an element exists in a partially-ordered range
ranges::binary_search
    determines if an element exists in a partially-ordered range

..alg_set_opertions
    includes
        returns true if one sequence is a subsequence of another
    ranges::includes
        returns true if one sequence is a subsequence of another
    set_union
        computes the union of two sets
    ranges::set_union
        computes the union of two sets
    set_intersection
        computes the intersection of two sets
    ranges::set_intersection
        computes the intersection of two sets
    set_difference
        computes the difference between two sets
    ranges::set_difference
        computes the difference between two sets
    set_symmetric_difference
        computes the symmetric difference between two sets
    ranges::set_symmetric_difference
        computes the symmetric difference between two sets

includes
    returns true if one sequence is a subsequence of another
ranges::includes
    returns true if one sequence is a subsequence of another
set_union
    computes the union of two sets
ranges::set_union
    computes the union of two sets
set_intersection
    computes the intersection of two sets
ranges::set_intersection
    computes the intersection of two sets
set_difference
    computes the difference between two sets
ranges::set_difference
    computes the difference between two sets
set_symmetric_difference
    computes the symmetric difference between two sets
ranges::set_symmetric_difference
    computes the symmetric difference between two sets

..alg_merge
    merge
        merges two sorted ranges
    ranges::merge
        merges two sorted ranges
    inplace_merge
        merges two ordered ranges in-place
    ranges::inplace_merge
        merges two ordered ranges in-place

merge
    merges two sorted ranges
ranges::merge
    merges two sorted ranges
inplace_merge
    merges two ordered ranges in-place
ranges::inplace_merge
    merges two ordered ranges in-place

..alg_heap
    std::make_heap
        A heap can be created by std::make_heap and ranges::make_heap(since C++20).
    ranges::make_heap
        A heap can be created by std::make_heap and ranges::make_heap(since C++20).
    push_heap
        adds an element to a max heap
    ranges::push_heap
        adds an element to a max heap
    pop_heap
        removes the largest element from a max heap
    ranges::pop_heap
        removes the largest element from a max heap
    make_heap
        creates a max heap out of a range of elements
    ranges::make_heap
        creates a max heap out of a range of elements
    sort_heap
        turns a max heap into a range of elements sorted in ascending order
    ranges::sort_heap
        turns a max heap into a range of elements sorted in ascending order
    is_heap
        checks if the given range is a max heap
    ranges::is_heap
        checks if the given range is a max heap
    is_heap_until
        finds the largest subrange that is a max heap
    ranges::is_heap_until
        finds the largest subrange that is a max heap

std::make_heap
    A heap can be created by std::make_heap and ranges::make_heap(since C++20).
ranges::make_heap
    A heap can be created by std::make_heap and ranges::make_heap(since C++20).
push_heap
    adds an element to a max heap
ranges::push_heap
    adds an element to a max heap
pop_heap
    removes the largest element from a max heap
ranges::pop_heap
    removes the largest element from a max heap
make_heap
    creates a max heap out of a range of elements
ranges::make_heap
    creates a max heap out of a range of elements
sort_heap
    turns a max heap into a range of elements sorted in ascending order
ranges::sort_heap
    turns a max heap into a range of elements sorted in ascending order
is_heap
    checks if the given range is a max heap
ranges::is_heap
    checks if the given range is a max heap
is_heap_until
    finds the largest subrange that is a max heap
ranges::is_heap_until
    finds the largest subrange that is a max heap

..alg_minmax
    max
        returns the greater of the given values
    ranges::max
        returns the greater of the given values
    max_element
        returns the largest element in a range
    ranges::max_element
        returns the largest element in a range
    min
        returns the smaller of the given values
    ranges::min
        returns the smaller of the given values
    min_element
        returns the smallest element in a range
    ranges::min_element
        returns the smallest element in a range
    minmax
        returns the smaller and larger of two elements
    ranges::minmax
        returns the smaller and larger of two elements
    minmax_element
        returns the smallest and the largest elements in a range
    ranges::minmax_element
        returns the smallest and the largest elements in a range
    clamp
        clamps a value between a pair of boundary values
    ranges::clamp
        clamps a value between a pair of boundary values

max
    returns the greater of the given values
ranges::max
    returns the greater of the given values
max_element
    returns the largest element in a range
ranges::max_element
    returns the largest element in a range
min
    returns the smaller of the given values
ranges::min
    returns the smaller of the given values
min_element
    returns the smallest element in a range
ranges::min_element
    returns the smallest element in a range
minmax
    returns the smaller and larger of two elements
ranges::minmax
    returns the smaller and larger of two elements
minmax_element
    returns the smallest and the largest elements in a range
ranges::minmax_element
    returns the smallest and the largest elements in a range
clamp
    clamps a value between a pair of boundary values
ranges::clamp
    clamps a value between a pair of boundary values

..alg_lexical_comp
    lexicographical_compare
        returns true if one range is lexicographically less than another
    ranges::lexicographical_compare
        returns true if one range is lexicographically less than another
    lexicographical_compare_three_way
        compares two ranges using three-way comparison

lexicographical_compare
    returns true if one range is lexicographically less than another
ranges::lexicographical_compare
    returns true if one range is lexicographically less than another
lexicographical_compare_three_way
    compares two ranges using three-way comparison
..alg_permut
    next_permutation
        generates the next greater lexicographic permutation of a range of elements
    ranges::next_permutation
        generates the next greater lexicographic permutation of a range of elements
    prev_permutation
        generates the next smaller lexicographic permutation of a range of elements
    ranges::prev_permutation
        generates the next smaller lexicographic permutation of a range of elements
    is_permutation
        determines if a sequence is a permutation of another sequence
    ranges::is_permutation
        determines if a sequence is a permutation of another sequence

next_permutation
    generates the next greater lexicographic permutation of a range of elements
ranges::next_permutation
    generates the next greater lexicographic permutation of a range of elements
prev_permutation
    generates the next smaller lexicographic permutation of a range of elements
ranges::prev_permutation
    generates the next smaller lexicographic permutation of a range of elements
is_permutation
    determines if a sequence is a permutation of another sequence
ranges::is_permutation
    determines if a sequence is a permutation of another sequence

..alg_numeric
    iota
        fills a range with successive increments of the starting value
    ranges::iota
        fills a range with successive increments of the starting value
    accumulate
        sums up or folds a range of elements
    inner_product
        computes the inner product of two ranges of elements
    adjacent_difference
        computes the differences between adjacent elements in a range
    partial_sum
        computes the partial sum of a range of elements
    reduce
        similar to std::accumulate, except out of order
    exclusive_scan
        similar to std::partial_sum, excludes the ith input element from the ith sum
    inclusive_scan
        similar to std::partial_sum, includes the ith input element in the ith sum
    transform_reduce
        applies an invocable, then reduces out of order
    transform_exclusive_scan
        applies an invocable, then calculates exclusive scan
    transform_inclusive_scan
        applies an invocable, then calculates inclusive scan

iota
    fills a range with successive increments of the starting value
ranges::iota
    fills a range with successive increments of the starting value
accumulate
    sums up or folds a range of elements
inner_product
    computes the inner product of two ranges of elements
adjacent_difference
    computes the differences between adjacent elements in a range
partial_sum
    computes the partial sum of a range of elements
reduce
    similar to std::accumulate, except out of order
exclusive_scan
    similar to std::partial_sum, excludes the ith input element from the ith sum
inclusive_scan
    similar to std::partial_sum, includes the ith input element in the ith sum
transform_reduce
    applies an invocable, then reduces out of order
transform_exclusive_scan
    applies an invocable, then calculates exclusive scan
transform_inclusive_scan
    applies an invocable, then calculates inclusive scan

..alg_random
    ranges::generate_random
        fills a range with random numbers from a uniform random bit generator

ranges::generate_random
    fills a range with random numbers from a uniform random bit generator

--- Views (ranges::views or views::) -- use as 'somecollection | views::xxx'

views::filter
    a view that consists of the elements of a range that satisfies a predicate

    auto even = [](int i) { return 0 == i % 2; };
    auto square = [](int i) { return i * i; };

    for (int i : std::views::iota(0, 6)
               | std::views::filter(even)
               | std::views::transform(square))
        std::cout << i << ' ';
    std::cout << '\n';

views::transform
    a view of a sequence that applies a transformation function to each element
    char rot13a(const char x, const char a)
    {
        return a + (x - a + 13) % 26;
    }
    char rot13(const char x)
    {
        if ('Z' >= x and x >= 'A')
            return rot13a(x, 'A');
        if ('z' >= x and x >= 'a')
            return rot13a(x, 'a');
        return x;
    }
    int main()
    {
        auto show = [](const unsigned char x) { std::putchar(x); };
        std::string in{"cppreference.com\n"};
        std::ranges::for_each(in, show);
        std::ranges::for_each(in | std::views::transform(rot13), show);

        std::string out;
        std::ranges::copy(std::views::transform(in, rot13), std::back_inserter(out));
        std::ranges::for_each(out, show);
        std::ranges::for_each(out | std::views::transform(rot13), show);
    }
views::take
    a view consisting of the first N elements of another view
    namespace views = std::views;
    auto print = [](char x){ std::cout << x; };

    for (const char nums[]{'1', '2', '3'};
         int n : views::iota(0, 5))
    {
        std::cout << "take(" << n << "): ";
        // safely takes only upto min(n, nums.size()) elements:
        std::ranges::for_each(nums | views::take(n), print);
        std::cout << '\n';
    }
    Output:

    take(0):
    take(1): 1
    take(2): 12
    take(3): 123
    take(4): 123
views::take_while
    a view consisting of the initial elements of another view, until the first
    element on which a predicate returns false

    for (int year : std::views::iota(2020)
                  | std::views::take_while([](int y){ return y < 2026; }))
        std::cout << year << ' ';
    std::cout << '\n';

    const char note[]{"Today is yesterday's tomorrow!..."};
    auto not_dot = [](char c){ return c != '.'; };
    for (char x : std::ranges::take_while_view(note, not_dot))
        std::cout << x;
    std::cout << '\n';

    Output:

    2020 2021 2022 2023 2024 2025
    Today is yesterday's tomorrow!
views::drop
    a view consisting of elements of another view, skipping the first N elements

    const auto nums = {1, 2, 3, 4, 5, 6, 7};
    std::cout << "drop " << 2 << ": ";
    for (int i : std::ranges::drop_view{nums, 2})
        std::cout << i << ' ';
    std::cout << '\n';
    std::cout << "drop " << 3 << ": ";
    for (int i : nums | std::views::drop(3))
        std::cout << i << ' ';
    std::cout << '\n';
    std::cout << "drop " << 4 << ": ";
    for (int i : std::views::iota(1, 8) | std::views::drop(4))
        std::cout << i << ' ';
    std::cout << '\n';
    // Note that dropping more than the number of elements is OK:
    for (int dp : {5, 6, 7, 890, 100500})
    {
        std::cout << "drop " << dp << ": ";
        for (int i : std::views::iota(1, 8) | std::views::drop(dp))
            std::cout << i << ' ';
        std::cout << '\n';
    }

    Output:

    drop 2: 3 4 5 6 7
    drop 3: 4 5 6 7
    drop 4: 5 6 7
    drop 5: 6 7
    drop 6: 7
    drop 7:
    drop 890:
    drop 100500:

views::drop_while
    a view consisting of the elements of another view, skipping the initial
    subsequence of elements until the first element where the predicate returns
    false

    using std::operator""sv; // string literal to string_view

    [[nodiscard]]
    constexpr bool is_space(char p) noexcept
    {
        auto ne = [p](auto q) { return p != q; };
        return !!(" \t\n\v\r\f" | std::views::drop_while(ne));
    };
    [[nodiscard("trims the output")]]
    constexpr std::string_view trim_left(std::string_view const in) noexcept
    {
        auto view = in | std::views::drop_while(is_space);
        return {view.begin(), view.end()};
    }
    [[nodiscard("trims the output")]]
    constexpr std::string trim(std::string_view const in)
    {
        auto view = in
                  | std::views::drop_while(is_space)
                  | std::views::reverse
                  | std::views::drop_while(is_space)
                  | std::views::reverse
                  ;
        return {view.begin(), view.end()};
    }
    int main()
    {
        static_assert(trim_left(" \n C++23") == "C++23"sv);

        constexpr auto src{" \f\n\t\r\vHello, C++20!\f\n\t\r\v "sv};
        static_assert(trim(src) == "Hello, C++20!");

        static constexpr auto v = {0, 1, 2, 3, 4, 5};
        for (int n : v | std::views::drop_while([](int i) { return i < 3; }))
            std::cout << n << ' ';
        std::cout << '\n';
    }
    Output:
    3 4 5
views::join
    a view consisting of the sequence obtained from flattening a view of ranges
    using namespace std::literals;

    const auto bits = {"https:"sv, "//"sv, "cppreference"sv, "."sv, "com"sv};
    for (char const c : bits | std::views::join)
        std::cout << c;
    std::cout << '\n';

    const std::vector<std::vector<int>> v{{1, 2}, {3, 4, 5}, {6}, {7, 8, 9}};
    auto jv = std::ranges::join_view(v);
    for (int const e : jv)
        std::cout << e << ' ';
    std::cout << '\n';

    Output:
    https://cppreference.com
    1 2 3 4 5 6 7 8 9
views::join_with
    a view consisting of the sequence obtained from flattening a view of ranges, with the delimiter in between elements

    using namespace std::literals;

    std::vector v{"This"sv, "is"sv, "a"sv, "test."sv};
    auto joined = v | std::views::join_with(' ');

    for (auto c : joined)
        std::cout << c;
    std::cout << '\n';

    Output:
    This is a test.
views::lazy_split
    a view over the subranges obtained from splitting another view using a delimiter
views::split
    a view over the subranges obtained from splitting another view using a delimiter

    using std::operator""sv;  // to string_view
    constexpr auto words{"Hello^_^C++^_^20^_^!"sv};
    constexpr auto delim{"^_^"sv};

    for (const auto word : std::views::split(words, delim))
        // with string_view's C++23 range constructor:
        std::cout << std::quoted(std::string_view(word)) << ' ';
    std::cout << '\n';

    Output:
    "Hello" "C++" "20" "!"
views::concat
    a view consisting of concatenation of the adapted views

    std::vector<int> v0{1, 2, 3}, v1{4, 5};
    int a[]{6, 7};
    int i{8};
    auto ie{std::views::single(i)};

    auto con = std::views::concat(v0, v1, a, ie);
    assert(con.size() == v0.size() + v1.size() + std::size(a) + ie.size());
    std::println("con.size(): {}", con.size());
    std::println("con: {}", con);
    con[6] = 42; // con is random_access_range, operator[] returns a reference
    assert(a[1] == 42); // a[1] was modified via con[6]
    std::println("con: {}", con);

    std::list<int> l{7, 8}; // list is bidirectional range
    auto cat = std::views::concat(v0, l);
    std::println("cat: {}", cat);
    // cat[0] = 13; // compile-time error: cat is bidirectional => no operator[]

    Output:
    con.size(): 8
    con: [1, 2, 3, 4, 5, 6, 7, 8]
    con: [1, 2, 3, 4, 5, 6, 42, 8]
    cat: [1, 2, 3, 7, 8]

views::counted
    creates a subrange from an iterator and a count

    const int a[]{1, 2, 3, 4, 5, 6, 7};
    for (int i : std::views::counted(a, 3))
        std::cout << i << ' ';
    std::cout << '\n';

    const auto il = {1, 2, 3, 4, 5};
    for (int i : std::views::counted(il.begin() + 1, 3))
        std::cout << i << ' ';
    std::cout << '\n';

    Output:

    1 2 3
    2 3 4

views::common
    converts a view into a common_range
views::reverse
    a view that iterates over the elements of another bidirectional view in reverse order

    static constexpr auto il = {3, 1, 4, 1, 5, 9};

    std::ranges::reverse_view rv{il};
    for (int i : rv)
        std::cout << i << ' ';
    std::cout << '\n';

    for (int i : il | std::views::reverse)
        std::cout << i << ' ';
    std::cout << '\n';

    // operator[] is inherited from std::view_interface
    for (auto i{0U}; i != rv.size(); ++i)
        std::cout << rv[i] << ' ';
    std::cout << '\n';

    Output:

    9 5 1 4 1 3
    9 5 1 4 1 3
    9 5 1 4 1 3
views::as_const
    converts a view into a constant_range

    int x[]{1, 2, 3, 4, 5};

    auto v1 = x | std::views::drop(2);
    assert(v1.back() == 5);
    v1[0]++; // OK, can modify non-const element

    auto v2 = x | std::views::drop(2) | std::views::as_const;
    assert(v2.back() == 5);
    // v2[0]++; // Compile-time error, cannot modify read-only element

views::elements
    takes a view consisting of tuple-like values and a number N and produces a view of Nth element of each tuple

    const std::vector<std::tuple<int, char, std::string>> vt
    {
        {1, 'A', "α"},
        {2, 'B', "β"},
        {3, 'C', "γ"},
        {4, 'D', "δ"},
        {5, 'E', "ε"},
    };

    for (int const e : std::views::elements<0>(vt))
        std::cout << e << ' ';
    std::cout << '\n';

    for (char const e : vt | std::views::elements<1>)
        std::cout << e << ' ';
    std::cout << '\n';

    for (std::string const& e : std::views::elements<2>(vt))
        std::cout << e << ' ';
    std::cout << '\n';

    Output:

    1 2 3 4 5
    A B C D E
    α β γ δ ε

views::keys
    takes a view consisting of pair-like values and produces a view of the first elements of each pair

    const std::vector<std::tuple<std::string, double, bool>> quark_mass_charge
    {
        // name, MeV/c², has positive electric-charge:
        {"up", 2.3, true}, {"down", 4.8, false},
        {"charm", 1275, true}, {"strange", 95, false},
        {"top", 173'210, true}, {"bottom", 4'180, false},
    };

    std::cout.imbue(std::locale("en_US.utf8"));
    std::cout << "Quark name:  │ ";
    for (std::string const& name : std::views::keys(quark_mass_charge))
        std::cout << std::setw(9) << name << " │ ";

    std::cout << "\n" "Mass MeV/c²: │ ";
    for (const double mass : std::views::values(quark_mass_charge))
        std::cout << std::setw(9) << mass << " │ ";

    std::cout << "\n" "E-charge:    │ ";
    for (const bool pos : std::views::elements<2>(quark_mass_charge))
        std::cout << std::setw(9) << (pos ? "+2/3" : "-1/3") << " │ ";
    std::cout << '\n';

    Output:

    Quark name:  │        up │      down │     charm │   strange │       top │    bottom │
    Mass MeV/c²: │       2.3 │       4.8 │     1,275 │        95 │   173,210 │     4,180 │
    E-charge:    │      +2/3 │      -1/3 │      +2/3 │      -1/3 │      +2/3 │      -1/3 │

views::values
    takes a view consisting of pair-like values and produces a view of the second elements of each pair

    const auto list = {std::pair{1, 11.1}, {2, 22.2}, {3, 33.3}};
    std::cout << "pair::second values in the list: ";
    for (double value : list | std::views::values)
        std::cout << value << ' ';

    std::map<char, int> map{{'A', 1}, {'B', 2}, {'C', 3}, {'D', 4}, {'E', 5}};
    auto odd = [](int x) { return 0 != (x & 1); };
    std::cout << "\nodd values in the map: ";
    for (int value : map | std::views::values | std::views::filter(odd))
        std::cout << value << ' ';
    std::cout << '\n';

    Output:

    pair::second values in the list: 11.1 22.2 33.3
    odd values in the map: 1 3 5

views::enumerate
    a view that maps each element of adapted sequence to a tuple of both the element's position and its value

    constexpr static auto v = {'A', 'B', 'C', 'D'};

    for (auto const [index, letter] : std::views::enumerate(v))
        std::cout << '(' << index << ':' << letter << ") ";
    std::cout << '\n';

    // create a map using the position of each element as key
    auto m = v | std::views::enumerate | std::ranges::to<std::map>();

    for (auto const [key, value] : m)
        std::cout << '[' << key << "]:" << value << ' ';
    std::cout << '\n';

    std::vector<int> numbers{1, 3, 5, 7};
    // num is mutable even with const, which does not propagate to reference to
    // make it const, use `std::views::enumerate(numbers) | std::views::as_const`
    // or `std::views::enumerate(std::as_const(numbers))`
    for (auto const [index, num] : std::views::enumerate(numbers))
    {
        ++num; // the type is int&
        std::cout << numbers[index] << ' ';
    }
    std::cout << '\n';

    Possible output:
    (0:A) (1:B) (2:C) (3:D)
    [0]:A [1]:B [2]:C [3]:D
    2 4 6 8

views::zip
    a view consisting of tuples of references to corresponding elements of the adapted views

    auto x = std::vector{1, 2, 3, 4};
    auto y = std::list<std::string>{"α", "β", "γ", "δ", "ε"};
    auto z = std::array{'A', 'B', 'C', 'D', 'E', 'F'};

    print("Source views:", "");
    print("x: ", x);
    print("y: ", y);
    print("z: ", z);

    print("\nzip(x,y,z):", "");

    for (std::tuple<int&, std::string&, char&> elem : std::views::zip(x, y, z))
    {
        std::cout << std::get<0>(elem) << ' '
                  << std::get<1>(elem) << ' '
                  << std::get<2>(elem) << '\n';

        std::get<char&>(elem) += ('a' - 'A'); // modifies the element of z
    }

    print("\nAfter modification, z: ", z);

    Output:

    Source views:
    x: 1 2 3 4
    y: α β γ δ ε
    z: A B C D E F

    zip(x,y,z):
    1 α A
    2 β B
    3 γ C
    4 δ D

    After modification, z: a b c d E F

views::zip_transform
    a view consisting of results of application of a transformation function to corresponding elements of the adapted views

    void print(auto const rem, auto const& r)
    {
        std::cout << rem << '{';
        for (char o[]{0,' ',0}; auto const& e : r)
            std::cout << o << e, *o = ',';
        std::cout << "}\n";
    }

    int main()
    {
        auto v1 = std::vector<float>{1, 2, 3};
        auto v2 = std::list<short>{1, 2, 3, 4};
        auto v3 = std::to_array({1, 2, 3, 4, 5});

        auto add = [](auto a, auto b, auto c) { return a + b + c; };

        auto sum = std::views::zip_transform(add, v1, v2, v3);

        print("v1:  ", v1);
        print("v2:  ", v2);
        print("v3:  ", v3);
        print("sum: ", sum);
    }
    Output:

    v1:  {1, 2, 3}
    v2:  {1, 2, 3, 4}
    v3:  {1, 2, 3, 4, 5}
    sum: {3, 6, 9}
views::adjacent
    a view consisting of tuples of references to adjacent elements of the adapted view
    (same also views::pairwise)

    constexpr std::array v{1, 2, 3, 4, 5, 6};
    std::cout << "v = [1 2 3 4 5 6]\n";

    for (int i{}; std::tuple t : v | std::views::adjacent<3>)
    {
        auto [t0, t1, t2] = t;
        std::cout << std::format("e = {:<{}}[{} {} {}]\n", "", 2 * i++, t0, t1, t2);
    }

    Output:

    v = [1 2 3 4 5 6]
    e = [1 2 3]
    e =   [2 3 4]
    e =     [3 4 5]
    e =       [4 5 6]

views::pairwise
    a view consisting of tuples of references to adjacent elements of the adapted view
    (same as views::adjacent<2>, see example there)

views::adjacent_transform
    a view consisting of results of application of a transformation function to adjacent elements of the adapted view

    constexpr static std::array data{1, 2, 3, 4, 5, 6};
    constexpr int window{3};

    auto Fun = [](auto... ints) { return (... + ints); };
    // Alternatively, the Fun could be any ternary (if window == 3) callable, e.g.:
    // auto Fun = [](int x, int y, int z) { return x + y + z; };

    constexpr auto view = data | std::views::adjacent_transform<window>(Fun);

    static_assert(
        view.size() == (data.size() - window + 1)
        && std::array{6, 9, 12, 15}
        == std::array{view[0], view[1], view[2], view[3]}
        && view[0] == Fun(data[0], data[1], data[2])
        && view[1] == Fun(data[1], data[2], data[3])
        && view[2] == Fun(data[2], data[3], data[4])
        && view[3] == Fun(data[3], data[4], data[5])
    );

    for (int x : view)
        std::cout << x << ' ';
    std::cout << '\n';

    Output:

    6 9 12 15

views::pairwise_transform
    a view consisting of results of application of a transformation function to adjacent elements of the adapted view
    Same as adjacent_transform<2>. See example there.

views::chunk
    a range of views that are N-sized non-overlapping successive chunks of the elements of another view

    auto print_subrange = [](std::ranges::viewable_range auto&& r)
    {
        std::cout << '[';
        for (int pos{}; auto elem : r)
            std::cout << (pos++ ? " " : "") << elem;
        std::cout << "] ";
    };

    int main()
    {
        const auto v = {1, 2, 3, 4, 5, 6};

        for (const unsigned width : std::views::iota(1U, 2U + v.size()))
        {
            auto const chunks = v | std::views::chunk(width);
            std::cout << "chunk(" << width << "): ";
            std::ranges::for_each(chunks, print_subrange);
            std::cout << '\n';
        }
    }
    Output:

    chunk(1): [1] [2] [3] [4] [5] [6]
    chunk(2): [1 2] [3 4] [5 6]
    chunk(3): [1 2 3] [4 5 6]
    chunk(4): [1 2 3 4] [5 6]
    chunk(5): [1 2 3 4 5] [6]
    chunk(6): [1 2 3 4 5 6]
    chunk(7): [1 2 3 4 5 6]

views::slide
    a view whose Mth element is a view over the Mth through (M + N - 1)th elements of another view

    auto print_subrange = [](std::ranges::viewable_range auto&& r)
    {
        std::cout << '[';
        for (char space[]{0,0}; auto elem : r)
            std::cout << space << elem, *space = ' ';
        std::cout << "] ";
    };

    int main()
    {
        const auto v = {1, 2, 3, 4, 5, 6};

        std::cout << "All sliding windows of width:\n";
        for (const unsigned width : std::views::iota(1U, 1U + v.size()))
        {
            auto const windows = v | std::views::slide(width);
            std::cout << "W = " << width << ": ";
            std::ranges::for_each(windows, print_subrange);
            std::cout << '\n';
        }
    }
    Output:

    All sliding windows of width W:
    W = 1: [1] [2] [3] [4] [5] [6]
    W = 2: [1 2] [2 3] [3 4] [4 5] [5 6]
    W = 3: [1 2 3] [2 3 4] [3 4 5] [4 5 6]
    W = 4: [1 2 3 4] [2 3 4 5] [3 4 5 6]
    W = 5: [1 2 3 4 5] [2 3 4 5 6]
    W = 6: [1 2 3 4 5 6]

views::chunk_by
    splits the view into subranges between each pair of adjacent elements for which the given predicate returns false

    void print_chunks(auto view, std::string_view separator = ", ")
    {
        for (auto const subrange : view)
        {
            std::cout << '[';
            for (std::string_view prefix; auto const& elem : subrange)
                std::cout << prefix << elem, prefix = separator;
            std::cout << "] ";
        }
        std::cout << '\n';
    }

    int main()
    {
        std::initializer_list v1 = {1, 2, 3, 1, 2, 3, 3, 3, 1, 2, 3};
        auto fn1 = std::ranges::less{};
        auto view1 = v1 | std::views::chunk_by(fn1);
        print_chunks(view1);

        std::initializer_list v2 = {1, 2, 3, 4, 4, 0, 2, 3, 3, 3, 2, 1};
        auto fn2 = std::ranges::not_equal_to{};
        auto view2 = v2 | std::views::chunk_by(fn2);
        print_chunks(view2);

        std::string_view v3 = "__cpp_lib_ranges_chunk_by";
        auto fn3 = [](auto x, auto y) { return not(x == '_' or y == '_'); };
        auto view3 = v3 | std::views::chunk_by(fn3);
        print_chunks(view3, "");

        std::string_view v4 = "\u007a\u00df\u6c34\u{1f34c}"; // "zß水🍌"
        auto fn4 = [](auto, auto ß) { return 128 == ((128 + 64) & ß); };
        auto view4 = v4 | std::views::chunk_by(fn4);
        print_chunks(view4, "");
    }
    Output:

    [1, 2, 3] [1, 2, 3] [3] [3] [1, 2, 3]
    [1, 2, 3, 4] [4, 0, 2, 3] [3] [3, 2, 1]
    [_] [_] [cpp] [_] [lib] [_] [ranges] [_] [chunk] [_] [by]
    [z] [ß] [水] [🍌]

views::stride
    a view consisting of elements of another view, advancing over N elements at a time

    void print(std::ranges::viewable_range auto&& v, std::string_view separator = " ")
    {
        for (auto const& x : v)
            std::cout << x << separator;
        std::cout << '\n';
    }

    int main()
    {
        print(std::views::iota(1, 13) | std::views::stride(3));
        print(std::views::iota(1, 13) | std::views::stride(3) | std::views::reverse);
        print(std::views::iota(1, 13) | std::views::reverse | std::views::stride(3));

        print("0x0!133713337*x//42/A$@"sv | std::views::stride(0B11) |
              std::views::transform([](char O) -> char { return 0100 | O; }),
              "");
    }
    Output:
    1 4 7 10
    10 7 4 1
    12 9 6 3
    password

views::cartesian_product
    a view consisting of tuples of results calculated by the n-ary cartesian product of the adapted views

    void print(std::tuple<char const&, int const&, std::string const&> t, int pos)
    {
        const auto& [a, b, c] = t;
        std::cout << '(' << a << ' ' << b << ' ' << c << ')' << (pos % 4 ? " " : "\n");
    }
    int main()
    {
        const auto x = std::array{'A', 'B'};
        const auto y = std::vector{1, 2, 3};
        const auto z = std::list<std::string>{"α", "β", "γ", "δ"};

        for (int i{1}; auto const& tuple : std::views::cartesian_product(x, y, z))
            print(tuple, i++);
    }
    Output:

    (A 1 α) (A 1 β) (A 1 γ) (A 1 δ)
    (A 2 α) (A 2 β) (A 2 γ) (A 2 δ)
    (A 3 α) (A 3 β) (A 3 γ) (A 3 δ)
    (B 1 α) (B 1 β) (B 1 γ) (B 1 δ)
    (B 2 α) (B 2 β) (B 2 γ) (B 2 δ)
    (B 3 α) (B 3 β) (B 3 γ) (B 3 δ)

--- Function objects
..fn_obj plus<void>
    function object implementing x + y
    auto string_plus = std::plus<void>{}; // “void” can be omitted
    std::string a = "Hello ";
    const char* b = "world";
    std::cout << string_plus(a, b) << '\n';
..fn_obj minus<void>
    function object implementing x - y
    auto complex_minus = std::minus<void>{}; // “void” can be omitted
    constexpr std::complex<int> z(4, 2);
    std::cout << complex_minus(z, 1) << '\n';
    std::cout << (z - 1) << '\n';
..fn_obj multiplies<void>
    function object implementing x * y
    auto complex_multiplies = std::multiplies<void>{}; // “void” can be omitted
    constexpr std::complex z1{1.0, 2.0}, z2{3.0, 4.0};
    std::cout << std::showpos
              << complex_multiplies(z1, z2) << ' ' << z1 * z2 << '\n';
..fn_obj divides<void>
    function object implementing x / y
    auto complex_divides = std::divides<void>{}; // “void” can be omitted
    constexpr std::complex z1{8.0, 4.0}, z2{1.0, 2.0};
    std::cout << std::showpos
              << complex_divides(z1, z2) << ' ' << z1 / z2 << '\n';
..fn_obj modulus<void>
    function object implementing x % y
    std::modulus<void>{}(m, 42); // calls operator%(M, int)
..fn_obj negate<void>
    function object implementing -x
    auto complex_negate = std::negate<void>{}; // “void” can be omitted
    constexpr std::complex z(4, 2);
    std::cout << complex_negate(z) << '\n';
..fn_obj equal_to<void>
    function object implementing x == y
    constexpr int a = 0, b = 8;
    std::equal_to<> equal{};
    static_assert(equal(a, a));
    static_assert(!equal(a, b));
..fn_obj not_equal_to<void>
    function object implementing x != y
    constexpr int p = 0, q = 8;
    std::not_equal_to<> not_equal{};
    static_assert(!not_equal(p, p));
    static_assert(not_equal(p, q));
..fn_obj greater<void>
    function object implementing x > y

    constexpr bool strictly_positive(int lhs)
    {
        return std::greater<>()(lhs, 0);
    }

    int main()
    {
        constexpr std::int64_t low = 0B11;
        constexpr std::uint16_t high = 0X11;
        std::greater<> greater{};
        static_assert(greater(high, low));

        constexpr static auto arr = {0, 1, 2, 3, 4, 5};
        static_assert(!std::all_of(arr.begin(), arr.end(), strictly_positive));
        static_assert(std::all_of(arr.begin() + 1, arr.end(), strictly_positive));
    }
..fn_obj less<void>
    function object implementing x < y

    constexpr bool strictly_negative(int lhs)
    {
        return std::less<>()(lhs, 0);
    }

    int main()
    {
        constexpr signed low = 010;
        constexpr unsigned high = 10;
        std::less<> less{};
        static_assert(less(low, high));

        constexpr static auto arr = {0, -1, -2, -3, -4, -5};
        static_assert(!std::all_of(arr.begin(), arr.end(), strictly_negative));
        static_assert(std::all_of(arr.begin() + 1, arr.end(), strictly_negative));
    }

..fn_obj greater_equal<void>
    function object implementing x >= y

    constexpr bool strictly_not_negative(int lhs)
    {
        return std::greater_equal<>()(lhs, 0);
    }

    int main()
    {
        constexpr int low = 0, high = 8;
        std::greater_equal<> greater_equal{};
        static_assert(greater_equal(high, low));
        static_assert(greater_equal(low, low));

        static constexpr auto arr = {-1, 0, 1, 2, 3, 4};
        static_assert(!std::all_of(arr.begin(), arr.end(), strictly_not_negative));
        static_assert(std::all_of(arr.begin() + 1, arr.end(), strictly_not_negative));
    }
..fn_obj less_equal<void>
    function object implementing x <= y

    constexpr bool strictly_not_positive(int lhs)
    {
        return std::less_equal<>()(lhs, 0);
    }

    int main()
    {
        constexpr int low = 0, high = 8;
        std::less_equal<> less_equal{};
        static_assert(less_equal(low, high));
        static_assert(less_equal(low, low));

        static constexpr auto arr = {1, 0, -1, -2, -3, -4};
        static_assert(!std::all_of(arr.begin(), arr.end(), strictly_not_positive));
        static_assert(std::all_of(arr.begin() + 1, arr.end(), strictly_not_positive));
    }
..fn_obj logical_and<void>
    function object implementing x && y
..fn_obj logical_or<void>
    function object implementing x || y
..fn_obj logical_not<void>
    function object implementing !x
..fn_obj bit_and<void>
    function object implementing x & y
..fn_obj bit_or<void>
    function object implementing x | y
..fn_obj bit_xor<void>
    function object implementing x ^ y
..fn_obj bit_not<void>
    function object implementing ~x

--- iterator library
reverse_iterator(
make_reverse_iterator(
back_insert_iterator(
back_inserter(
front_insert_iterator(
front_inserter(
insert_iterator(
inserter(
basic_const_iterator(
const_iterator(
const_sentinel(
make_const_iterator(
make_const_sentinel(
move_iterator(
move_sentinel(
make_move_iterator(
common_iterator(
default_sentinel_t(
counted_iterator(
unreachable_sentinel_t(
istream_iterator(
ostream_iterator(
istreambuf_iterator(
ostreambuf_iterator(
advance(
distance(
next(
prev(
ranges::advance(
ranges::distance(
ranges::next(
ranges::prev(

--- vim:tw=78:ts=4:sw=4:sts=4:et:fo+=t:
