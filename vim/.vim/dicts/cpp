--- Keep words short, otherwise info popup window will have no space.
--- useful shortcuts
vector<int>
vector<
vector<vector<int>>
vector<vector<
vector<char>
vector<string>
string
set<int>
set<
map<
unordered_map<
pair<int, int>
first
second

--- from cppreference.com
--- keywords
alignas
alignof
and
and_eq
asm
atomic_cancel
atomic_commit
atomic_noexcept
auto
bitand
bitor
bool
break;
case
catch
char
char8_t
char16_t
char32_t
class
compl
concept
const
consteval
constexpr
constinit
const_cast
continue;
co_await
co_return
co_yield
decltype
default
delete
do
double
dynamic_cast
else
enum
explicit
export
extern
false
float
for(
friend
goto
if(
inline
int
long
mutable
namespace
new
noexcept
not
not_eq
nullptr
operator
or
or_eq
private
protected
public
reflexpr
register
reinterpret_cast
requires
return
short
signed
sizeof
static
static_assert
static_cast
struct
switch
synchronized
template
this
thread_local
throw
true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchar_t
while(
xor
xor_eq
final
override
transaction_safe
transaction_safe_dynamic
import
module
--- memory management
unique_ptr
shared_ptr
weak_ptr
--- vector
front()
back()
data()
begin()
cbegin()
end()
cend()
rbegin()
crbegin()
rend()
crend()
empty()
size()
max_size()
reserve(
capacity(
shrink_to_fit()
clear()
insert(
insert_range(
emplace(
erase()
push_back(
emplace_back(
append_range(
pop_back(
resize(
swap(
--- list and deque
push_front(
emplace_front(
prepend_range(
pop_front(
splice(
remove(
remove_if(
reverse(
unique(
sort(

list::
    -> implemented as a doubly-linked list.
    operator= -> assigns values to the container
    assign() -> assigns values to the container
    assign_range() -> assigns a range of values to the container
    get_allocator() -> returns the associated allocator
    front() -> access the first element
    back() -> access the last element
    begin()
    cbegin()
    end()
    cend()
    rbegin()
    crbegin() -> returns a reverse iterator to the beginning
    rend()
    crend() -> returns a reverse iterator to the end()
    empty() -> checks whether the container is empty
    size() -> returns the number of elements
    max_size() -> returns the maximum possible number of elements
    clear() -> clears the contents
    insert() -> inserts elements
    insert_range() -> inserts a range of elements
    emplace() -> constructs element in-place
    erase() -> erases elements
    push_back() -> adds an element to the end
    emplace_back() -> constructs an element in-place at the end
    append_range() -> adds a range of elements to the end
    pop_back() -> removes the last element
    push_front() -> inserts an element to the beginning
    emplace_front() -> constructs an element in-place at the beginning
    prepend_range() -> adds a range of elements to the beginning
    pop_front() -> removes the first element
    resize() -> changes the number of elements stored
    swap() -> swaps the contents
    merge() -> merges two sorted lists
    splice() -> moves elements from another list
    remove() -> removes elements satisfying specific criteria
    remove_if() -> removes elements satisfying specific criteria
    reverse() -> reverses the order of the elements
    unique() -> removes consecutive duplicate elements (keeps the first)
    sort() -> sorts the elements

--- list::list -> std::list<int> l = {7, 5, 16, 8}; l.push_back(13); l.push_front(25);
--- list::list -> std::list<int> c1(3, 100); // [100, 100, 100]
--- 
--- list::assign() -> std::list<char> characters; characters.assign(5, 'a'); // a a a a a
--- list::assign() -> const std::string extra(6, 'b'); characters.assign(extra.begin(), extra.end()); // b b b b b b
--- list::assign() -> characters.assign({'C', '+', '+', '1', '1'}); // C + + 1 1
--- 
--- list::assign_range() -> auto source = std::vector{2, 7, 1}; auto destination = std::list{3, 1, 4}; destination.assign_range(source);
--- 
--- list::front() -> assert(letters.front() == 'a');
--- list::back() -> assert(letters.back() == 'd');
--- list::empty() -> returns bool
--- list::size() -> returns number (unsigned long, size_type)
--- list::clear() -> listx.clear()
--- list::insert() -> iterator insert( const_iterator pos, const T& value ); (1)
--- list::insert() -> iterator insert( const_iterator pos, T&& value ); (2)
--- list::insert() -> iterator insert( const_iterator pos, size_type count, const T& value ); (3)
--- list::insert() -> template< class InputIt > iterator insert( const_iterator pos, InputIt first, InputIt last ); (4)
--- list::insert() -> iterator insert( const_iterator pos, std::initializer_list<T> ilist ); (5)
--- list::insert() -> std::list<int> c1(3, 100); auto pos = c1.begin(); pos = c1.insert(pos, 200); // [200, 100, 100, 100]
--- list::insert() -> c1.insert(pos, 2, 300); // [300, 300, 200, 100, 100, 100]
--- list::insert() -> pos = c1.begin();
--- list::insert() -> std::list<int> c2(2, 400); c1.insert(std::next(pos, 2), c2.begin(), c2.end()); // [300, 300, 400, 400, 200, 100, 100, 100]
--- list::insert() -> int arr[] = {501, 502, 503};
--- list::insert() -> c1.insert(c1.begin(), arr, arr + std::size(arr)); // [501, 502, 503, 300, 300, 400, 400, 200, 100, 100, 100]
--- list::insert() -> c1.insert(c1.end(), {601, 602, 603}); // [501, 502, 503, 300, 300, 400, 400, 200, 100, 100, 100, 601, 602, 603]
--- 
--- list::insert_range() -> auto container = std::list{1, 2, 3, 4}; auto pos = std::next(container.begin(), 2);
--- list::insert_range() -> const auto rg = std::vector{-1, -2, -3}; container.insert_range(pos, rg);
--- 
--- list::erase() -> iterator erase( const_iterator pos );
--- list::erase() -> iterator erase( const_iterator first, const_iterator last );
--- list::erase() -> Returns iterator following the last removed element.
--- list::erase() -> c.erase(range_begin, range_end);
--- list::erase() -> it = c.erase(it);
--- 
--- list::push_back() -> letters.push_back("abc"); // return none
--- list::append_range() -> auto head = std::list{1, 2, 3, 4}; const auto tail = std::vector{-5, -6, -7}; head.append_range(tail);
--- list::pop_back() -> numbers.pop_back(); // return none
--- list::push_front() -> letters.push_front("abc"); or letters.push_front(std::move(s)); // return none;
--- list::prepend_range() -> auto container = std::list{0, 1, 2, 3}; const auto rg = std::vector{-3, -2, -1}; container.prepend_range(rg);
--- list::pop_front() -> chars.pop_front() // return none
--- 
--- list::resize() -> void resize( size_type count );
--- list::resize() -> void resize( size_type count, const value_type& value );
--- list::resize() -> (see deque::resize) std::list<int> c = {1, 2, 3}; c.resize(5); c.resize(2); c.resize(6, 4);
--- 
--- list::swap() -> a1.swap(a2);
--- list::merge() -> list1.sort(); list2.sort(); list1.merge(list2); // result is sorted also, return none
--- list::splice() ->
--- list::splice() -> std::list<int> list1{1, 2, 3, 4, 5}; std::list<int> list2{10, 20, 30, 40, 50};
--- list::splice() -> auto it = list1.begin(); std::advance(it, 2); list1.splice(it, list2);
--- list::splice() -> list2 is empty, list1: 1 2 10 20 30 40 50 3 4 5, 'it' points to 3 even after splicing
--- list::splice() -> list2.splice(list2.begin(), list1, it, list1.end()); // list1: 1 2 10 20 30 40 50 list2: 3 4 5
--- 
--- list::remove() -> auto count1 = l.remove(1); // count1 elements (equal to 1) are removed
--- list::remove_if() -> auto count2 = l.remove_if([](int n){ return n > 10; }); // count2 elements are removed
--- list::reverse() -> list.reverse(); // return none
--- list::unique() -> size_type unique(); // returns number of elements removed
--- list::sort() -> list.sort(); list.sort(std::greater<int>()); // return none

deque::
deque::at() -> access specified element with bounds checking
deque::operator[] -> access specified element
deque::front() -> access the first element
deque::back() -> access the last element
deque::begin
deque::cbegin
deque::end
deque::cend
deque::rbegin
deque::crbegin() -> returns a reverse iterator to the beginning
deque::rend
deque::crend() -> returns a reverse iterator to the end
deque::empty() -> checks whether the container is empty
deque::size() -> returns the number of elements
deque::max_size() -> returns the maximum possible number of elements
deque::shrink_to_fit() -> (DR*) reduces memory usage by freeing unused memory
deque::clear() -> clears the contents
deque::insert() -> inserts elements
deque::insert_range() -> inserts a range of elements
deque::emplace() -> constructs element in-place
deque::erase() -> erases elements
deque::push_back() -> adds an element to the end
deque::emplace_back() -> constructs an element in-place at the end
deque::append_range() -> adds a range of elements to the end
deque::pop_back() -> removes the last element
deque::push_front() -> inserts an element to the beginning
deque::emplace_front() -> constructs an element in-place at the beginning
deque::prepend_range() -> adds a range of elements to the beginning
deque::pop_front() -> removes the first element
deque::resize() -> changes the number of elements stored
deque::swap() -> swaps the contents

deque::deque -> std::deque<int> d = {7, 5, 16, 8}; d.push_front(13); d.push_back(25);
deque::deque -> std::deque<int> c1(3, 100);

deque::insert -> iterator insert( const_iterator pos, const T& value );
deque::insert -> iterator insert( const_iterator pos, T&& value );
deque::insert -> iterator insert( const_iterator pos, size_type count, const T& value );
deque::insert -> template< class InputIt > iterator insert( const_iterator pos, InputIt first, InputIt last );
deque::insert -> auto pos = c1.begin(); pos = c1.insert(pos, 200);
deque::insert -> c1.insert(pos, 2, 300); // overload (3)
deque::insert -> c1.insert(std::next(pos, 2), c2.begin(), c2.end());
deque::insert -> c1.insert(c1.end(), {601, 602, 603});

deque::insert_range -> auto container = std::deque{1, 2, 3, 4}; auto pos = std::next(container.begin(), 2);
deque::insert_range -> const auto rg = std::list{-1, -2, -3}; container.insert_range(pos, rg); container.insert(pos, rg.cbegin(), rg.cend());

deque::erase -> c.erase(c.begin()); c.erase(c.begin() + 2, c.begin() + 5); it = c.erase(it);

deque::append_range -> auto head = std::deque{1, 2, 3, 4}; const auto tail = std::list{-5, -6, -7};
deque::append_range -> head.append_range(tail); head.insert(head.end(), tail.cbegin(), tail.cend());
deque::prepend_range -> (see append_range) container.prepend_range(rg);

deque::push_back -> letters.push_back("abc"); // returns nothing
deque::pop_back -> numbers.pop_back(); // returns nothing
deque::push_front -> letters.push_front("abc"); // returns nothing
deque::pop_front -> chars.pop_front(); // returns nothing
deque::swap -> a1.swap(a2);

deque::resize -> std::deque<int> c = {1, 2, 3}; c.resize(5); // After resize up to 5: 1 2 3 0 0
deque::resize -> c.resize(2); // After resize down to 2: 1 2
deque::resize -> c.resize(6, 4); // After resize up to 6 (initializer = 4): 1 2 4 4 4 4

stack:: -> wrapper around deque (see deque)
stack::top() -> accesses the top element
stack::empty() -> checks whether the container adaptor is empty
stack::size() -> returns the number of elements
stack::push() -> inserts element at the top
stack::push_range() -> inserts a range of elements at the top
stack::emplace() -> constructs element in-place at the top
stack::pop() -> removes the top element
stack::swap() -> swaps the contents

queue:: -> wrapper around deque (see deque)
queue::front() -> access the first element
queue::back() -> access the last element
queue::empty() -> checks whether the container adaptor is empty
queue::size() -> returns the number of elements
queue::push() -> inserts element at the end
queue::push_range() -> inserts a range of elements at the end
queue::emplace() -> constructs element in-place at the end
queue::pop() -> removes the first element
queue::swap() -> swaps the contents

--- map and set
insert_or_assign(
emplace_hint(
try_emplace(
extract(
merge(
count()
find(
contains(
equal_range(
lower_bound(
upper_bound(
key_comp(
value_comp(
map::at() <-> access specified element with bounds checking
map::operator[] <-> access or insert specified element
map::begin() <-> returns an iterator to the beginning
map::cbegin() <-> returns an iterator to the beginning
map::end() <-> returns an iterator to the end
map::cend() <-> returns an iterator to the end
map::rbegin() <-> returns a reverse iterator to the beginning
map::crbegin() <-> returns a reverse iterator to the beginning
map::rend() <-> returns a reverse iterator to the end
map::crend() <-> returns a reverse iterator to the end
map::empty() <-> checks whether the container is empty
map::size() <-> returns the number of elements
map::max_size() <-> returns the maximum possible number of elements
map::clear() <-> clears the contents
map::insert() <-> inserts elements or nodes(since C++17)
map::insert_range() <-> inserts a range of elements
map::insert_or_assign() <-> inserts an element or assigns to the current element if the key already exists
map::emplace() <-> constructs element in-place
map::emplace_hint() <-> constructs elements in-place using a hint
map::try_emplace() <-> inserts in-place if the key does not exist, does nothing if the key exists
map::erase() <-> erases elements
map::swap() <-> swaps the contents
map::extract() <-> extracts nodes from the container
map::merge() <-> splices nodes from another container
map::count() <-> returns the number of elements matching specific key
map::find() <-> finds element with specific key
map::contains() <-> checks if the container contains element with specific key
map::equal_range() <-> returns range of elements matching a specific key
map::lower_bound() <-> returns an iterator to the first element not less than the given key
map::upper_bound() <-> returns an iterator to the first element greater than the given key
map::key_comp() <-> returns the function that compares keys
map::value_comp() <-> returns the function that compares keys in objects of type value_type

map::map -> map<int, int> f {{1,2},{3,4}};
map::map -> auto f = map{pair{1, 11}, {3, 33}, {2, 22}, {4, 44}};
map iterate -> for (const auto& [key, value] : m) std::cout << '[' << key << "] = " << value << "; ";

map::insert -> mapx.insert(pair(1,2))
map::insert -> mapx.insert({1,2})
map::insert -> mapx.insert(rg.begin(), rg.end()); -> const auto rg = {std::pair{-1, -11}, {3, -33}, {-2, -22}};
map::insert -> mapx.insert(rg); -> const auto rg = {std::pair{-1, -11}, {3, -33}, {-2, -22}}; (-> vector)

map::emplace -> mapx.emplace("d", "ddd"); -> map<std::string, std::string> mapx;
map::emplace -> mapx.emplace(std::make_pair("b", "abcd"));

map::erase() -> it = mapx.erase(it);
map::erase() -> Removes the element at pos, or in the range [first, last), or with the key==a_key
map::erase() -> Returns iterator following the last removed element, or Number of elements removed.
map::erase() -> std::erase_if(m, [](const auto& pair){ return pair.second > 25; });

map::swap -> mapx.swap(mapy);

map::count -> size_type map::count( const Key& key )

map::find -> if(auto search = map_foo.find(2); map_foo != example.end()) std::cout << "Found " << map_foo->first << ' ' << map_foo->second << '\n';

map::contains -> if (mapx.contains(x))

map::equal_range -> auto p = m.equal_range(key); for (auto& q = p.first; q != p.second; ++q) cout<<q->first<<q->second;
map::lower_bound -> auto p = m.lower_bound(key);
map::upper_bound -> auto p = m.upper_bound(key);

set::begin()
set::cbegin()
set::end()
set::cend()
set::rbegin()
set::crbegin()
set::rend() <-> returns a reverse iterator to the end
set::crend() <-> returns a reverse iterator to the end
set::empty() <-> checks whether the container is empty
set::size() <-> returns the number of elements
set::max_size() <-> returns the maximum possible number of elements
set::clear() <-> clears the contents
set::insert() <-> inserts elements or nodes(since C++17)
set::insert_range() <-> inserts a range of elements
set::emplace() <-> constructs element in-place
set::emplace_hint() <-> constructs elements in-place using a hint
set::erase() <-> erases elements
set::swap() <-> swaps the contents
set::extract() <-> extracts nodes from the container
set::merge() <-> splices nodes from another container
set::count() <-> returns the number of elements matching specific key
set::find() <-> finds element with specific key
set::contains() <-> checks if the container contains element with specific key
set::equal_range() <-> returns range of elements matching a specific key
set::lower_bound() <-> returns an iterator to the first element not less than the given key
set::upper_bound() <-> returns an iterator to the first element greater than the given key
set::key_comp() <-> returns the function that compares keys
set::value_comp() <-> returns the function that compares keys in objects of type value_type

set::set -> set<int> set{1, 5, 3};  // can name a set as 'set'
set::empty -> if (set.empty())
set::insert -> set.insert(2);
set::erase -> set.erase(1);
set::contains -> if (set.contains(key))

set print -> for_each(set.begin(), set.end(), [&out](const T& element) out << ", " << element;

set::clear() -> setx.clear();

set::insert() -> auto result_1 = set.insert(3); assert(result_1.first != set.end()); // it is a valid iterator
set::insert() -> auto result_1 = set.insert(3); assert(*result_1.first == 3); if (!result_2.second) std::cout << "no insertion\n";

set::insert_range() -> const auto rg = {-1, 3, -2}; setx.insert_range(rg); OR setx.insert(rg.begin(), rg.end());

set::erase() -> it = c.erase(it); // see map::erase, can use iterators

set::swap() -> a1.swap(a2); Every iterator referring to an element in one container before the swap refers to the same element in the other container after the swap.

set::find() -> if (auto search = example.find(2); search != example.end())
set::contains() -> if (example.contains(x))
set::equal_range() -> auto [begin, end] = characters.equal_range(names); (see map::equal_range)
set::lower_bound() -> no example
set::upper_bound() -> no example

--- string
assign(
assign_range(
c_str(
length(
append(
replace_with_range(
resize_and_overwrite(
find(
rfind(
find_first_of(
find_first_not_of(
find_last_of(
find_last_not_of(
compare(
starts_with(
ends_with(
substr(start, length)

std::string	std::basic_string<char>
std::wstring	std::basic_string<wchar_t> // wide string
std::u8string   std::basic_string<char8_t>
std::u16string  std::basic_string<char16_t>
std::u32string  std::basic_string<char32_t>

string:: -> mutable (unlike java string, and C's char *f="foo"
string::operator= -> assigns values to the string
string::assign() -> assign characters to a string
string::assign_range() -> assign a range of characters to a string
string::get_allocator() -> returns the associated allocator
string::at() -> accesses the specified character with bounds checking
string::operator[]() -> accesses the specified character
string::front() -> accesses the first character
string::back() -> accesses the last character
string::data() -> returns a pointer to the first character of a string
string::c_str() -> returns a non-modifiable standard C character array version of the string
string::operator() -> basic_string_view returns a non-modifiable basic_string_view into the entire string
string::begin()
string::cbegin()
string::end()
string::cend()
string::rbegin()
string::crbegin() -> returns a reverse iterator to the beginning
string::rend()
string::crend() -> returns a reverse iterator to the end
string::empty() -> checks whether the string is empty
string::size() -> returns the number of characters
string::length() -> returns the number of characters
string::max_size() -> returns the maximum number of characters
string::reserve() -> reserves storage
string::capacity() -> returns the number of characters that can be held in currently allocated storage
string::shrink_to_fit() -> reduces memory usage by freeing unused memory
string::clear() -> clears the contents
string::insert() -> inserts characters
string::insert_range() -> inserts a range of characters
string::erase() -> removes characters
string::push_back() -> appends a character to the end
string::pop_back() -> removes the last character
string::append() -> appends characters to the end
string::append_range() -> appends a range of characters to the end
string::operator+=() -> appends characters to the end
string::replace() -> replaces specified portion of a string
string::replace_with_range() -> replaces specified portion of a string with a range of characters
string::copy() -> copies characters
string::resize() -> changes the number of characters stored
string::resize_and_overwrite() -> changes the number of characters stored and possibly overwrites indeterminate contents via user-provided operation
string::swap() -> swaps the contents
string::find() -> finds the first occurrence of the given substring
string::rfind() -> find the last occurrence of a substring
string::find_first_of() -> find first occurrence of characters
string::find_first_not_of() -> find first absence of characters
string::find_last_of() -> find last occurrence of characters
string::find_last_not_of() -> find last absence of characters
string::compare() -> compares two strings
string::starts_with() -> checks if the string starts with the given prefix
string::ends_with() -> checks if the string ends with the given suffix
string::contains() -> checks if the string contains the given substring or character
string::substr() -> returns a substring

string::(non-member fn) operator+ concatenates two strings, a string and a char, or a string and string_view
string::(non-member fn) operator== operator!= operator< operator> operator<= operator>= operator<=> lexicographically compares two strings
string::(non-member fn) std::swap(std::basic_string) specializes the std::swap algorithm
string::(non-member fn) std::erase(std::basic_string) erases all elements satisfying specific criteria
string::(non-member fn) std::erase_if(std::basic_string) erases all elements satisfying specific criteria
string::(non-member fn)
string::(non-member fn) operator<< operator>> -> performs stream input and output on strings
string::(non-member fn) getline() -> read data from an I/O stream into a string
string::(non-member fn) stoi() stol() stoll() -> converts a string to a signed integer
string::(non-member fn) stoul() stoull() -> converts a string to an unsigned integer
string::(non-member fn) stof() stod() stold() -> converts a string to a floating point value
string::(non-member fn) to_string() -> converts an integral or floating-point value to string
string::(non-member fn) to_wstring() -> converts an integral or floating-point value to wstring

string::assign -> s.assign(4, '='); // "===="; s.assign(c); // assign(const basic_string& str)
string::assign -> s.assign(c, 0, c.length() - 1); assign(const basic_string& str, size_type pos, size_type count)
string::assign -> s.assign(std::string("C++ by ") + "example"); // assign(basic_string&& str)
string::assign -> s.assign("C-style string", 7); // assign(const CharT* s, size_type count)
string::assign -> s.assign("C-style\0string"); // assign(const CharT* s)
string::assign -> char mutable_c_str[] = "C-style string"; s.assign(std::begin(mutable_c_str), std::end(mutable_c_str) - 1); // assign(InputIt first, InputIt last)
string::assign -> s.assign({'C', '-', 's', 't', 'y', 'l', 'e'}); // assign(std::initializer_list<CharT> ilist)

string::assign_range() -> destination.assign_range(source); // same as destination.assign(source.begin(), source.end());

string::insert() -> s.insert(0, 1, 'E'); // insert(size_type index, size_type count, char ch)
string::insert() -> s.insert(2, "e"); // insert(size_type index, const char* s)
string::insert() -> s.insert(6, "a"s); // insert(size_type index, string const& str)
string::insert() -> s.insert(8, " is an example string."s, 0, 14); // insert(size_type index, string const& str, size_type s_index, size_type count)
string::insert() -> s.insert(s.cbegin() + s.find_first_of('n') + 1, ':'); // insert(const_iterator pos, char ch)
string::insert() -> s.insert(s.cbegin() + s.find_first_of(':') + 1, 2, '='); // insert(const_iterator pos, size_type count, char ch)
string::insert() -> s.insert(s.begin() + s.find_last_of('e') + 1, std::begin(seq), std::end(seq)); // insert(const_iterator pos, InputIt first, InputIt last)
string::insert() -> s.insert(s.cbegin() + s.find_first_of('g') + 1, {'.'}); // insert(const_iterator pos, std::initializer_list<char>)

string::insert_range() -> target.insert_range(iter, source); // same as target.insert(iter, source.begin(), source.end());

string::erase() -> std::string s = "This Is An Example"; s.erase(7, 3); // erases " An"
string::erase() -> s.erase(std::find(s.begin(), s.end(), ' ')); // erases first ' ';
string::erase() -> s.erase(s.find(' ')); // trims from ' ' to the end of the string;
string::erase() -> auto it = std::next(s.begin(), s.find('s')); // obtains iterator to the first 's'
string::erase() -> s.erase(it, std::next(it, 2)); // erases "sI";

string::push_back() -> str.push_back('!');
string::pop_back() -> str.pop_back();

string::append -> std::basic_string<char> str = "string";
string::append -> const char* cptr = "C-string";
string::append -> const char carr[] = "Two and one";
string::append -> std::string output;
string::append -> output.append(3, '*'); // 1) Append a char 3 times. 
string::append -> output.append(str); // 2) Append a whole string
string::append -> output.append(str, 3, 3); // 3) Append part of a string (last 3 letters, in this case)
string::append -> output.append(1, ' ').append(carr, 4); // 4) Append part of a C-string. `append` returns *this, we can chain calls together
string::append -> output.append(cptr); // 5) Append a whole C-string
string::append -> output.append(&carr[3], std::end(carr)); // 6) Append range
string::append -> output.append({' ', 'l', 'i', 's', 't'}); // 7) Append initializer list

string::append_range() -> 
string::operator+=() -> 
string::replace() -> 
string::replace_with_range() -> 
string::copy() -> 
string::resize() -> 
string::resize_and_overwrite() -> 
string::swap() -> 
string::find() -> 
string::rfind() -> 
string::find_first_of() -> 
string::find_first_not_of() -> 
string::find_last_of() -> 
string::find_last_not_of() -> 
string::compare() -> 
string::starts_with() -> 
string::ends_with() -> 
string::contains() -> 
string::substr() -> 


--- constrained algorithms (ranges algorithms)
ranges::
ranges::all_of(
ranges::any_of(
ranges::none_of(
ranges::for_each(
ranges::for_each_n(
ranges::count(
ranges::count_if(
ranges::mismatch(
ranges::equal(
ranges::lexicographical_compare(
ranges::find(
ranges::find_if(
ranges::find_if_not(
ranges::find_last(
ranges::find_last_if(
ranges::find_last_if_not(
ranges::find_end(
ranges::find_first_of(
ranges::adjacent_find(
ranges::search(
ranges::search_n(
ranges::contains(
ranges::contains_subrange(
ranges::starts_with(
ranges::ends_with(
ranges::copy(
ranges::copy_if(
ranges::copy_n(
ranges::copy_backward(
ranges::move(
ranges::move_backward(
ranges::fill(
ranges::fill_n(
ranges::transform(
ranges::generate(
ranges::generate_n(
ranges::remove(
ranges::remove_if(
ranges::remove_copy(
ranges::remove_copy_if(
ranges::replace(
ranges::replace_if(
ranges::replace_copy(
ranges::replace_copy_if(
ranges::swap_ranges(
ranges::reverse(
ranges::reverse_copy(
ranges::rotate(
ranges::rotate_copy(
ranges::shuffle(
ranges::shift_left(
ranges::shift_right(
ranges::sample(
ranges::unique(
ranges::unique_copy(
ranges::is_partitioned(
ranges::partition(
ranges::partition_copy(
ranges::stable_partition(
ranges::partition_point(
ranges::is_sorted(
ranges::is_sorted_until(
ranges::sort(
ranges::partial_sort(
ranges::partial_sort_copy(
ranges::stable_sort(
ranges::nth_element(
ranges::lower_bound(
ranges::upper_bound(
ranges::binary_search(
ranges::equal_range(
ranges::merge(
ranges::inplace_merge(
ranges::includes(
ranges::set_difference(
ranges::set_intersection(
ranges::set_symmetric_difference(
ranges::set_union(
ranges::is_heap(
ranges::is_heap_until(
ranges::make_heap(
ranges::push_heap(
ranges::pop_heap(
ranges::sort_heap(
ranges::max(
ranges::max_element(
ranges::min(
ranges::min_element(
ranges::minmax(
ranges::minmax_element(
ranges::clamp(
ranges::is_permutation(
ranges::next_permutation(
ranges::prev_permutation(
ranges::iota(
ranges::fold_left(
ranges::fold_left_first(
ranges::fold_right(
ranges::fold_right_last(
ranges::fold_left_with_iter(
ranges::fold_left_first_with_iter(
ranges::uninitialized_copy(
ranges::uninitialized_copy_n(
ranges::uninitialized_fill(
ranges::uninitialized_fill_n(
ranges::uninitialized_move(
ranges::uninitialized_move_n(
ranges::uninitialized_default_construct(
ranges::uninitialized_default_construct_n(
ranges::uninitialized_value_construct(
ranges::uninitialized_value_construct_n(
ranges::destroy(
ranges::destroy_n(
ranges::destroy_at(
ranges::construct_at(
ranges::generate_random(
ranges::in_fun_result(
ranges::in_in_result(
ranges::in_out_result(
ranges::in_in_out_result(
ranges::in_out_out_result(
ranges::min_max_result(
ranges::in_found_result(
ranges::in_value_result(
ranges::out_value_result(
--- iterator library
reverse_iterator(
make_reverse_iterator(
back_insert_iterator(
back_inserter(
front_insert_iterator(
front_inserter(
insert_iterator(
inserter(
basic_const_iterator(
const_iterator(
const_sentinel(
make_const_iterator(
make_const_sentinel(
move_iterator(
move_sentinel(
make_move_iterator(
common_iterator(
default_sentinel_t(
counted_iterator(
unreachable_sentinel_t(
istream_iterator(
ostream_iterator(
istreambuf_iterator(
ostreambuf_iterator(
advance(
distance(
next(
prev(
ranges::advance(
ranges::distance(
ranges::next(
ranges::prev(
